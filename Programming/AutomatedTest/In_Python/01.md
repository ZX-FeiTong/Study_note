# 第 1 章：自动化测试概述

如今，在与程序员相关的就业市场中，除了大家所熟悉的、软件开发类的岗位之外，软件测试工程师也是一个颇具发展前景的热门岗位。毕竟，几乎所有大中型的软件产品在发布前都需要完成大量的质量控制、测试和文档工作，这些工作通常大约会占用掉整个软件项目中 50% 的时间和总成本，而软件测试工程师就是负责这部分工作的重要岗位。然而我们面对的现实情况是：一方面是就业市场对高质量的测试工程师需求量越来越大，另一方面则因为国内教育方面在过去的很长一段时间里对测试工作的重视程度不够，让很多人根本不了解这项工作的具体内容及其在软件工程中的重要性，这最终到导致了中国在这方面的优质人才供给存在着较大的缺口。据笔者曾经看过的一些调查数据显示，中国目前在软件业每年都会新增约 20 万测试类的岗位需求，但相关学校与培训机构培养出的软件测试人才不足这个需求量的 10%，并且需求与供给间的差距仍在进一步拉大。

正是基于这样的市场现况，我们计划在这本书中从零开始介绍与软件测试及其自动化实现相关的知识，期内容将会以自动化测试和测试框架开发的进阶技术为主线，以 Python 作为编程语言，充分地把 Python 语言在测试开发上的优势展现出来，致力于完整、详尽地探讨单元测试、性能测试、UI 测试、接口测试、持续集成等主要议题，并通过实战案例帮助读者快速掌握这些技术。

在本章，让我们先来对自动化测试做一些概念性的知识梳理和学习路线图的规划，以便读者在后续的学习中能获得一个鸟瞰式的全局视野，并做到有的放矢，从而达到事半功倍的学习效果。总而言之，希望读者在阅读完本章内容之后能够：

- 理解软件测试是一项怎样的工作，包括这项工作的目标定义、任务分类以及工作原则；
- 理解在测试工作中使用自动化技术的意义，并了解自动化测试的核心能力及其局限所在；
- 了解学习自动化所需要学习的知识，并根据本书的章节安排规划好后期要执行的路线图；

## 1.1 测试工作简介

正如本章开头所说，在目前的市场上，软件测试领域的人才供应是远远不能满足实际需求的，这其中的原因除了社会整体对这项工作的重要性认知不足之外，软件开发团队中的各个成员，尤其是项目管理层对测试工作的定义存在着不符合科学的偏差也是我们要面对的一大问题。所以在正式介绍自动化测试的相关概念之前，我们首先要花点时间来让读者了解一下软件测试究竟是一项怎样的工作。具体来说就是，我们有必要先帮助初学者定义好这项工作所要达成的目标、需要做的事情以及要遵守的工作原则。

### 1.1.1 测试工作的定义

读者首先要了解的是，软件测试这项工作虽然属于计算机科学的领域，但它同时也需要考虑一些与经济学与心理学相关的因素。例如在理想状态下，软件的开发商在心理上会希望测试工作能检查出软件所有的情况，并证明它是一个“没有错误”的产品，但这个要求在实际生产环境中是无法被满足的。首先，从科学角度上来说，有很大概率并不存在“没有错误”的软件，因为科学本身就是一个不断发现错误并提出解决思路的学科。其次，即使真的存在着“没有错误”的软件，而如果我们想要证明这种存在的话，那就需要在测试中穷举出该软件可能遇到的所有情况，并证明软件对每一种情况的应对都符合设计人员对它的预期，这在经济学上也显然是不现实的，因为哪怕是最简单的程序（例如某一排序算法）也可能存在着成千上万种以上的执行路径与输入/输出，恐怕没有哪一个软件的开发商能支付得起这等规模的、且需旷日持久的测试工作。所以，如果我们想要真正地做好软件测试这项工作，首先要定义好工作的内容及其要达成的目标，解决好其中存在的主观心理愿望与客观经济成本之间的冲突。

要想正确地定义软件测试的工作内容，我们首先需要对它有一个符合科学现实的愿景。如果程序员一开始就将这项工作定义为是“证明软件的运行符合预期的过程”或者“向客户证明软件可靠的过程”，那么就会出现不符合科学的愿景，就像上面说的，最终会走向证明软件没有错误的道路，然后就成了一个不可能完成的任务。造成这种主客观冲突的主要根源在于，我们人类在心理上更倾向于执行具有建设性的任务，例如程序员在开发一个软件时很自然地就会希望得到项目经理的认可，客户的买单，所以行为上就会会下意识地去制造软件可靠且符合预期的假象。但测试一个软件的真正价值在于发现软件中还没有被发现的错误，或者所有人都没有预期到的情况，以便开发人员能继续提升软件的质量。换而言之，软件测试本质上是一个破坏性的任务，我们要干的实际上是类似在鸡蛋里挑骨头的、直觉上不讨人喜欢的工作。

如果想要让人们克服对建设性的心理需求，转而干不讨人喜欢的挑刺工作，首先就需要明确任务成功的目标。具体来说就是，我们不能认为没有发现错误的测试是一次成功的测试，测试工作的目标就是要尽可能地找到软件中可以重现给其开发人员的错误。这就好像一个病人到医院看病，如果做了一堆检查之后什么问题也没有找到，这显然不能说是一次成功的检查，毕竟只有找到病因，医生才能对症下药。只有保有这样的工作态度，我们才能确保自己不会在无意中做一个对软件相对友善的、让它尽快通过测试并交付给客户的老好人，而会从一开始就铁了心做一个千方百计对软件“施虐”的坏人。

综上所述，软件测试应该被定义成一项“为了发现错误而执行程序”的工作。

### 1.1.2 测试工作的分类

如果读者想要对软件测试这项工作建构起一个全面性的认知，除了要理解测试工作的具体定义之外，了解这项工作中可以执行哪些类型的任务也是非常重要的。基本上，我们可以基于测试工作的各种不同目标和需求，将测试工作中可执行的主要任务分类如下：

- **单元测试**：这一类测试通常是指对软件中的最小可测试单元进行检查和验证。至于“单元”的大小或范围，并没有一个明确的标准，“单元”可以是一个函数、方法、类、功能模块或者子系统。值得一提的是，单元测试往往被人和白盒测试联系到一起（关于什么是白盒测试，我们稍后会在 1.3.1 节中做详细介绍），虽然单就概念上来说，两者是有区别的，但单元测试和白盒测试通常都可被看做是针对代码逻辑的测试，所以在某些语境下也可以认为这两者是同一个东西。
- **性能测试**：性能测试是通过设计一些特定的测试用例来模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。
- **UI 测试**：在这一类测试中，测试工程师们会通过设计一些特定的测试用例来模拟用户在应用程序界面（例如 CUI、GUI 或 Web）上进行的鼠标点击、键盘输入等交互操作。在该测试过程中，这些测试用例会将模拟操作得到的反馈与正常情况下的人机交互反馈进行对比，以便找出 UI 的设计缺陷。
- **接口测试**：接口测试是最为常见的软件测试任务之一，它通常需要测试工程师们能够排除图形化界面的影响，并针对软件功能本身进行测试。它是软件业务逻辑测试中非常关键的一步。通常在一个软件项目的早期阶段，接口测试就会同步开始进行，以便随时找出代码中存在的各种错误。另外，由于接口测试不使用 GUI，它将主要通过字符界面的方式与测试者进行交互。

关于上述类型的测试任务在具体工作中的执行方式，我们将会在本书的第 4 章中再为读者做详尽的介绍和贴近实战的演示，在这里，读者只需要先对这些测试任务的分类有一个概念性的认知即可。

### 1.1.3 测试工作的原则

在理解了测试工作中所要做的事情，及其要达成的目标之后，读者接下来要考虑的就是如何做好一个铁了心要对待测软件进行“施虐”的坏人了。而如果我们想在测试任务中扮演好这种坏人的角色，就需要在工作实践中建立起一些基本原则，按照《软件测试的艺术》这本书中的建议[^1]，我们可以归纳出如下工作原则。

- **程序员或开发团队应该避免测试自己编写的软件**：这很好理解，既然软件测试工作的本质是要对待测的软件展开各种“施虐”，那自然最好要对自己的作品进行回避，否则就很难保证测试结果不被人类的主观心理影响；
- **在测试用例中必须提出对软件输出或执行结果的预期**：或许很多人不相信，这条理想当然得像废话一样的原则却恰恰是软件测试工作中最常见的错误之一。这其中存在的实际上是一个心理学的问题，即如果测试人员没有就测试用例在待测软件上得到的执行结果做出明确且清晰的预期，由于“所见即所想”现象的存在，某个似是而非的、但实际上是错误的结果就可能会人们下意识地被解释成正确的结论。而克服这种下意识行为的一种方法，就是通过事先精确定义程序的预期输出，鼓励人们对所有的输出进行仔细检查；
- **每个测试用例的执行结果都应该得到充分的检查**：这也是一个显而易见到像废话一样，但很容易被忽视的原则。在大量的测试案例中，我们经常会看到：即便某个错误的症状在用例的输出清单中已经清晰可见，但测试人员硬就是没有注意到这个错误的存在；
- **测试过程中不仅要考虑有效的数据和可以预期的执行结果，也要考虑无效的数据和预计不到的执行结果**：测试人员在测试软件时通常有一个很自然的心理倾向，即将重点集中在有效和预期的输入情况上，而忽略了无效和未预料到的情况。然而，软件产品在被使用过程中被爆出的许多问题往往都是在它以某些新的或未预料到的方式运行时发现的。因此，针对未预料到的和无效输入情况的测试用例，似乎比针对有效输入情况的那些用例更具有价值；
- **测试过程中不仅要观察软件是否做了它该做的事情，也要关注它是否做了它不该做的事情**：这条原则是上条原则的必然结果。必须检查程序是否有我们不希望的负作用。例如，如果某个公司的工资管理系统可以为它的每个员工生成正确的工资单，我们就可以认为它做了该做的事，但如果该系统也为公司的非雇员生成了相同的工资单，这也会是一个不小的错误，我们的测试工作应该找到它做了这项不该做的事；
- **我们使用的测试用例应该是可以重复执行的，用例的执行结果也应该是可以重现的**：这个原则也是非常重要且显而易见的，试想一下，如果我们精心设计的测试用例在发现某个错误并提交了报告之后就被丢弃了，一旦软件在完成修改之后需要重新测试，那就又必须重新设计这些测试用例。这除了是人力资源的巨大浪费之外，我们也很难保证重新设计的测试用例能对上一次发现的问题进行确认。除此之外，软件其他部分的被修改之后，也可能会导致已经被测试过的部分出现新的问题，这就需要对其进行回归测试，这也需要我们保留并重复使用自己的测试用例；
- **在制定工作计划，开发测试用例时不能假设软件中不存在错误**：这是项目经理们经常容易犯的一种错误，这也是因为他们对测试工作有了不符合科学规律的预期。也就是说，他们误以为测试是一个“证明程序能正确运行”的过程，但测试实际上是“为发现错误而执行程序“的过程，关于这两种认知的差异及其造成的影响，我们之前已经做了详细的解释说明，这里就不再重复了；
- **软件的某一部分中可能存在的实际错误数量通常与该部分已经被发现的错误成正比**：在各种类型的工程中，人们总是会观察到一种错误扎堆出现的现象，软件工程也不例外，每个软件都总是免不了会出现几个出错频率很高的部件。尽管没有人能够对这种现象给出很好的解释，但这也足以让工程师们形成某种工作经验了。换言之，如果程序的某个部分远比其他部分更容易产生错误，那么工程师们就可以基于这种经验对这部分进行重点测试，以便让测试工作获得更大的成效；
- **明白软件测试一个极富创造性的工作，它对程序员带来的挑战并不低于软件开发**：也许很多人没有意识到一个事实：测试一个大型软件所需要完成的创造性工作在很多情况下是超过该软件本身的开发的。正如我们之前所解释的，要想充分地测试一个软件并确保所有错误都不存在几乎是不可能的。这意味着，工程师们需要使用一系列特定的技术，并针对具体的软件来设计出合理的测试用例集，而这显然需要工程师们完成大量的创造性工作；

除了上述基本原则之外，对于某些具体的测试工作来说，妥善利用自动化技术来提升测试的效率和质量也被认为是一个非常重要的工作原则，这也让自动化测试成为了软件测试工程师必须要学习的一项重要技能。这项技能如今在广为流行的敏捷开发、持续交付和持续集成等新型软件工程理念中已经享有着至关重要的地位。下面就让我们趁热打铁，继续带读者来了解一下实现自动化测试的意义，以及使用这项技能所能完成的核心作用和它的能力局限所在。

[^1]:《软件测试的艺术》（The Art of Software Testing）被誉为软件测试工程师入门“圣经”，书中对软件测试的任务类型、用例的设计方法、测试策略等议题都有精彩且具体的论述，其中的许多经典论断至今仍被广为引用。特别值得一提的是，此书的篇幅仅 100 多页，非常适合专业人员每年都精读一次，每次都会有新的感悟。

## 1.2 实现测试的自动化

在这里，我们所谓的“自动化测试”，实际上指的就是利用计算机的自动化操作能力来完成一些特定的测试任务，目的是解决人工执行的测试操作会带来的各种效率和成本问题。具体来说就是，工程师们使用独立于待测软件之外的自动化脚本，及其他软件工具来完成测试任务，并生成相应测试报告的过程。在这个过程中，工程师们会利用特定的软件工具记录用户操作，并在后续测试中重复这些操作，或通过编写测试用例的方式来模拟人工测试。

### 1.2.1 实现自动化的意义

诚如大家所知，随着我们在生产环境中开发的软件系统在规模上越来越庞大，对这些软件系统的测试也在变得更加困难和复杂，这也使得传统的人工测试将越来越难以胜任相关的工作任务。因此，我们也越来越需要利用自动化技术来克服传统测试技术的许多问题，在原则上，只要某一软件的测试流程是已经确定了的，那么实现针对它的自动化测试在理论上就具备了一定的意义，毕竟这样做既可以让我们在工作效率上快速地执行一些重复但必须要完成的测试工作，也可以从工作规模上来完成一些人工测试几乎不可能完成的任务。

当然了，仅仅从理论上理解自动化测试的意义是不够的。毕竟，自动化测试本身也会给软件项目带来高昂的成本，并且也不是在所有情况下都所有良好的效果，所以我们还需要从实际生产需要的角度来理解为什么某些项目需要实现测试的自动化，或者说这些项目在什么情况下才需要进行自动化测试。因为只有这样，我们才能在具体的测试工作中做到有的放矢，让测试的自动化实现达到锦上添花的效果，而不是画蛇添足。而想要达到这种效果，我们就需要理清楚的是：一个项目是否该引入自动化测试究竟取决于哪些因素？

首先，软件项目的开发时间毫无疑问是其中一个需要重点考虑的因素。如果一个软件测试项目要执行的只是一个短期任务，例如它从立项到结束只有一个月的时间，而这一个月的时间可能相当长的时间都是用来和客户确定需求，编写测试用例等，实际留给测试工作的时间往往是很少的。在这种情况下，无论是基于时间成本还是工作效率的考虑，人工测试都绝对是第一选择。毕竟，项目可能连测试用例的设计工作都还没有完成，随时可能要改变测试操作，这时在其中引入自动化测试显然是没有意义的。但是，一旦该项目变成了一个周期较长的的测试任务，就可以考虑在其中引入自动化测试了。因为在这种情况下，测试用例的设计通常会比较稳定，使用自动化技术对人工测试进行模拟就具有了现实意义。

除了时间因素之外，自动化测试所能带来的实际开销和工作效率也是我们要考虑的因素。通常情况下，自动化测试相对比较容易在大型软件企业的项目中得到实施，因为它们更有实力承担相关的成本，并发挥出自动化技术的优势，然后再借助该优势来获得较高的投资回报率。这也意味着，我们大概也只有在以下这几类项目中引入自动化测试，才能提出它在软件工程中的真正价值。

- **产品型项目**：这类项目的特点是每次修改通常都只涉及少量的功能，但在整个项目周期中都必须反反复复的测试那些没有改动过的功能。在这种情况下，后一部分的测试完全可以让自动化测试来承担， 同时对新增功能的测试也会慢慢地被加入到自动化测试当中。
- **采用增量式开发、持续集成的项目**：由于这类项目的开发方式需要频繁地发布软件的新版本，自然也就需要频繁地进行对应的自动化测试，以便把人力从中解脱出来测试新的功能。
- **能够自动编译、自动发布的项目**：如果想要实现完全的自动化测试，软件项目就必须要具有自动化编译、自动化发布的能力。当然，不能达到这个要求的软件系统也往往可以在人工干预的情况下进行自动化测试。
- **包含大量重复性、机械性操作的项目**：在这种情况下，我们最好的选择就是将这类烦琐的任务转化为自动化测试。毕竟，自动化测试最适用于执行多次重复、机械性的操作，例如，向系统输入大量的相似数据来测试压力和报表。
- **需要频繁运行测试的项目**：如果我们发现一个项目中需要频繁地运行某一测试任务，且测试的周期按天计算，那就应该最大限度地将这一测试任务的执行自动化。

需要提醒读者的是，我们在考虑项目中引入自动化测试的意义时，千万不要将人工测试与自动化测试的关系对立起来。如今，有许多人误以为只要采用了自动化测试，项目中就不需要人工测试了，甚至认为实现自动化测试的意义就是有朝一日替代掉项目中所有的人工测试，这样做就本末倒置了。事实上，这二者并不是对立的，人工测试执行的主体是人类，主要将能通过人为的逻辑判断来效验当前的步骤是否正确，它往往有较强的随机应变能力，但在测试步骤之间可能会存在思维比较跳跃、缺乏稳定性之类的问题。而自动化测试执行测试的主体是自动化脚本，主要将通过预先定义的逻辑规则来效验当前的步骤是否正确，它的测试步骤之间关联性强，不像人工测试那么能应对突发状况。正因为这两者在测试工作中是各有所长的互补关系，所以优秀的测试工程师就该学会善用自己的技能，做好人工测试与自动化测试的分工。而这就需要他们充分理解自动化测试的核心能力，以及这种能力的局限所在。

### 1.2.2 核心能力及其局限

从具体工作内容上来说，自动化测试的核心工作就是通过制定一套严密的测试法则和评估标准，从而定义出一个完整的自动测试流程。也正因为如此，它才可以有效地避免测试工程师因某种惯性思维或迷信经验而导致的测试疏漏。下面，让我们通过举例来具体了解一下自动化在具体测试任务中的作用。

首先，让我们来看单元测试。这一类测试的自动化被认为是极限编程和敏捷开发这类新型开发方式的一个关键衍生，由它主导的开发过程通常被称之为测试驱动开发。在这一类开发活动中，单元测试的用例可以在开发人员编写完应用程序的业务代码之前就完成预先设计，并作为对这一部分业务目标的一种定义。然后，随着代码编写进度的不断推进，单元测试随之同步进行，代码中存在的Bug 也将被不断找出，并被持续纠正和完善。由于开发人员能够及时发现缺陷然后立即作出改变，修复的代价大大减小，这种不断发展的开发方式被认为比瀑布模型这类开发结束再测试的方式更为可靠。正因为如此，在项目开发过程中使用单元测试框架来实现自动化测试也已经成为了目前软件开发行业的一大趋势。

接下来，让我们再来看看回归测试。如果读者之前做过一些软件测试的工作，大概都应该知道如果以人工测试的方式来对大量的低级接口进行回归测试将会是一件十分耗时费工的事情，况且这种寻找 Bug  的效率还非常低下。而一旦这部分的测试实现了自动化，日后的测试工作将可以高效循环完成。很多时候这是针对软件产品进行长期回归测试的高效方法。毕竟，早期一个微小的补丁中引入的回归问题可能在日后导致巨大的损失。

当然了，凡事都有作用的局限性，事情做过了头就会带来反效果。尽管从整个软件开发周期来看，自动化测试可以软件开发活动带来开支上的节省，但如果我们一味地追求将所有的测试工作完全自动化，那么对自动化测试本身的实现也有可能会在短期内给项目团队带来巨大的开销。毕竟，虽然测试本身可以实现“自动化”，但对测试脚本维护和编写仍然需要大量的人工来投入。因此在实际生产环境中，测试工程师们会根据软件测试的具体需求采用人工测试和自动化测试相结合的方法来完成相任务。通常情况下，我们将一项测试工作自动化需满足以下要求：

- **对测试用例的要求**：可被自动化的测试用例大多是目标项目在每次被修改之后都需要进行回归测试的重要部分。只有在这种情况下，对相关代码实现测试的自动化才能有效地降低人工测试消耗的人力物力。
- **对测试人员的要求**：由于在将自动化测试的过程中，测试用例和输出结果也都是由以代码的形式存在的，因此这就要求测试工程师们本身也必须具备编程语言的使用能力。当然了，某些自动化测试工具支持通过关键词指定测试步骤，因而免除了程序编写的过程，对测试人员而言也就不再要求他们掌握编程技术了。
- **对项目团队的要求**：是否要对测试过程实现自动化，最终还是要取决于开发目标项目的团队是否真的需要自动化，这需要项目团队的管理者根据要被测试的目标系统、测试工作的规模和种类、可使用的测试工具、人和组织的工作重心等因素进行综合考虑来做出决策。

对于上述要求中的最后一项，如果我们是某个项目团队的管理者，就需要具体了解究竟有哪几种测试是可以实现自动化的，只有这样我们才能根据项目进行回归测试的必要性、经济因素、被测系统成熟度来做出决定。通常来说，以下类型的项目应该是不适合引入自动化测试的。

- **一次性的定制型项目**：这种一次性为客户定制的项目，维护期由客户方承担的，甚至采用的开发语言、运行环境也是客户特别要求的，即公司在这方面的测试积累就少，这样的项目不适合作自动化测试。
- **项目周期很短的项目**：项目周期很短，测试周期很短，就不值得花精力去投资自动化测试，好不容易建立起的测试脚本，不能得到重复的利用是不现实的。
- **业务规则复杂的项目**：在业务规则复杂的项目中，往往存在着有很多的逻辑关系、运算关系，它们是很难使用自动化技术来进行测试的。
- **功能与人类感官相关的项目**：在人的感观方面，例如与用户界面的美观、声音的体验、易用性相关的测试，通常也只能由人类来测试。
- **测试任务很少的项目**：如果测试任务很少，当然就没有必要实现测试的自动化，不然就是一种浪费了。自动化测试要执行的就是那些需要不厌其烦的、反反复复的测试任务。
- **尚未达到稳定状态的项目**：如果软件项目的运行状态本身还不稳定，那么这些不稳定因素大概率会导致自动化测试失败。只有当软件项目的运行达到相对稳定的状态，没有界面性严重错误和中断错误才能开始自动化测试。
- **涉及物理设备交互的项目**：如果软件项目在运行过程中需要与其他物理设备进行交互，例如刷信用卡操作，那么它们就很难使用自动化技术来进行测试。

## 1.3 学习自动化测试的路线图

在了解了自动化测试的基本概念、核心工作任务及其能力局限之后，我们就可以来具体规划进入这一领域的学习路线图了。根据个人的经验。我在这里会建议读者：首先，了解在进行软件测试工作时所需要的基础知识，这部分的主要内容包括软件测试的基本策略、用例设计方法等；然后，掌握一两门在软件测试工作中需要使用的编程语言及其相关工具，例如 Java、Python、Ruby、JavaScript 等；最后，掌握一两款当今主流自动化测试框架的使用方法。下面，让我们基于本书接下来的内容来做一些更具体的学习建议，以供读者参考。

### 1.3.1 软件测试的基本策略

在学习软件测试的基础知识方面，除了之前提到的测试任务分类，我们还需要对测试要采取的策略有所了解，例如，人们经常提到的黑盒测试和白盒测试就是两种基本的测试策略。下面，就让我们先来了解一下它们。

- **黑盒测试**：这类测试策略有时也被称为数据驱动的测试或输入/输出驱动的测试。在该策略之下，测试人员会将待测的软件看作某种不透明的黑盒子，并根据该软件的开发者提供用户手册来对其进行测试，以便找出软件的输入/输出中不符合用户手册的地方。在这种情况下，测试工作将与软件内部的具体实现方式完全无关，其测试用例设计的依据也主要来自于用户手册中制定的输入规范。换而言之，如果我们想单纯依靠这种测试策略来找出待测软件中的所有错误，就得穷举所有被用户手册允许的输入。
- **白盒测试**：这类测试策略有时也被称为逻辑驱动的测试。在该策略之下，测试人员会将待测的软件看作可以看到内部构造的透明盒子，并基于对该软件内部构造的分析来对其进行测试，以便找出软件在业务逻辑实现上的错误。在这种情况下，测试工作将与软件内部的具体实现方式息息相关，其测试用例设计的依据也主要来自于测试人员对软件代码的审阅。换而言之，如果我们想单纯依靠这种测试策略来找出待测软件中的所有错误，就得穷举该软件源代码中每一种可能的执行路径。

很显然，在生产环境中，无论是穷举输入还是穷举执行路径都是不现实的，因此在实际设计测试用例时，我们通常只会根据要测试的对象和具体的测试需求来搭配使用以上两种策略，这需要测试人员在工作时间中不断总结经验并提炼解决方案的。例如，以下就是时下常见的 4 种解决方案。

- **等价类划分**：在该解决方案中，测试人员会倾向于预先设定若干个输入域的集合，相同集合的中每个输入条件都将被视为是等效的，如果其中一个输入不能导致问题的发生，那么同一集合中其它输入条件进行测试也不太可能发现错误。这其实是基于黑盒测试策略来设计的一种测试方案，它在一定程度上规避了穷举所有输入的必要性。
- **边界值分析**：该解决方案的理论基础是假定大多数的错误是发生在各种输入条件的边界上，如果在边界附近的取值不会导致程序出错，那么其它的取值导致程序错误的可能性也很小。这也是基于黑盒测试策略来设计的一种测试方案，它在很大程度上缩小了要测试的输入数量。
- **判定表**：判定表是分析和表达多种输入条件下系统执行不同动作的工具，它可以把复杂的逻辑关系和多种条件组合的情况表达得既具体又明确 。显而易见，这是基于白盒测试策略来设计的一种测试方案，它实际上是实现了对源代码执行路径的分组测试。
- **流程分析法**：在该解决方案中，测试人员会将软件系统的各种流程看成其源代码的执行路径，然后再使用路径分析的方法来设计测试用例。根据流程的顺序依次进行组合，使得流程的各个分支都能走到。显然，这是另一种基于白盒测试策略来设计的测试方案，它能有效地减少要测试的代码执行路径。

关于测试用例设计的具体流程，我们将会在第 4 章中结合不同类型的测试任务来为读者做更详细的介绍和演示。在这里，读者同样只需要对软件测试的基本策略有一个概念性的认知即可。

### 1.3.2 掌握要使用的编程语言

虽然在自动化测试领域，我们可以使用的编程语言包括有 Java、Python、Ruby、JavaScript 等多种选择，但考虑到时下市场上常用的第三方框架和集成化测试工具，Python 无疑是其中最经济，同时也是最实用的选择之一。所以在这里，我们希望读者知道，如果想要很好地学习本书后续章节中探讨的各种议题，掌握 Python 语言的基本语法及其标准库的使用方法无疑是先决条件。虽然在这本书中，我们原则上会假定读者已经掌握了这门语言的基本使用，但对于“掌握”的标准，我们还是希望先和读者做一些约定。首先，自然是要能正确地安装和配置 Python 语言运行环境，掌握这一能力的标准是读者能在自己的计算机环境中顺利地执行以下 Hello World 程序：

```Python
#! /usr/bin/env python

def main():
    print("Hello, Python!")

if __name__ == '__main__':
    main()
```

接下来，读者需要掌握的是 Python 语言的标准语法，包括灵活运用各种表达式语句、条件语句、循环语句，以及会使用标准库提供的各种数据类型和数据结构，掌握这一能力的标准是能理解并复述下面代码中实现的 4 种排序算法，并能正确地调用它们：

```Python
#! /usr/bin/env python

import random

def radixSort(coll, length):
    if(coll == []): return []
    
    for d in xrange(length):
        LSD = [[] for _ in xrange(10)]
        for n in coll:
            LSD[n / (10 ** d) % 10].append(n)
        coll = [tmp_a for tmp_b in LSD for tmp_a in tmp_b]
    
    return coll

def insertSort(coll):
    if(coll == []): return []
    for i in range(1,len(coll)):
        j = i
        while j > 0 and coll[j-1] > coll[j]:
             coll[j-1], coll[j] = coll[j], coll[j-1]  
             j -= 1
              
    return coll 

def shellSort(coll):
    if(coll == []): return []
    size = len(coll)
    step = size / 2
    while(step >= 1):
        for i in range(step, size):
            tmp = coll[i]
            ins = i
            while(ins >= step and tmp < coll[ins - step]):
                coll[ins] = coll[ins - step]
                ins -= step
            coll[ins] = tmp
        step = step / 2
    
    return coll

def quickSort(coll):
    if(coll == []): return []
    return quickSort([x for x in coll[1:] if x < coll[0]]) + \
                         coll[0:1] + \
                         quickSort([x for x in coll[1:] if x >= coll[0]])
```

最后，在最理想的情况下，读者还应该具备能针对某一特定任务来引入相关的标准模块或第三扩展，并编写出自动化脚本的能力，例如能理解并复述下面这段实现 Git 提交操作的自动化脚本，这是我们后续学习编写测试用例的基础。

```Python
#! /usr/bin/env python

import os
import sys
import time

if not len(sys.argv) in range(2, 4):
    print("Usage: git_commit.py <git_dir> [commit_message]") 
    exit(1)

title = "=    Starting " + sys.argv[0] + "......    ="
n = len(title)
print(n*'=')
print(title)
print(n*'=')

os.chdir(sys.argv[1])
print("work_dir: " + sys.argv[1])
if len(sys.argv) == 3 and sys.argv[2] != "":
    commit_message = sys.argv[2]
else:
    commit_message = "committed at " + time.strftime("%Y-%m-%d",time.localtime(time.time()))

os.system("git add .")
os.system("git commit -m '"+ commit_message + "'")

print("Commit is complete!")

print(n*'=')    
print("=     Done!" + (n-len("=     Done!")-1)*' ' + "=")
print(n*'=')
```

如果读者在基于以上标准的自我检验中遇到了一些绕不过去的障碍，我们会强烈建议先回过头去补习一下 Python 语言的基本使用方法。为了解决这一方面的问题，我们在本书的第 2 章特别设置了一个专题教程，希望它能帮助读者实现对这门语言的快速上手。总而言之，只有等读者达到了我们在这里约定的、对 Python 语言的掌握标准，才能更好地应对后续章节的学习与实践，以便实现最好的学习效果。

### 1.3.3 学习自动化测试框架

自动化测试框架泛指的是某种为特定产品设置一系列特定测试规则并自动化执行这些规则的集成系统。这套系统中通常整合了各种用于测试的函数库、测试数据集、元数据和各种可重用模块。将这些模块按照测试需求组合起来便可以得到一个完整的，针对特定功能或应用场景的测试用例。测试框架为自动化测试提供基础，并简化了自动化测试的工作流程。

在面向 Web 应用程序的的自动化测试工作中，Selenium 和 Robot 这两个框架是当前软件测试工程师们最主流的两种选择。其中，Selenium 框架是时下在 Web 领域最常用的自动化测试工具之一，它能帮助我们快速开发出自动化测试用例，且 跨各种平台、跨多种编程语言（包括 Java、Python）支持在多种浏览器上开展测试工作。该框架的学习曲线比较平缓，对于编程经验不是很丰富的测试人员来说，使用 Python+Selenium 这一组合工具是个很好的选择。

而 Robot Framwork 则是一款更为通用的、可扩展的、支持关键字驱动的自动化测试框架，通常被专业的测试工程师们用于端到端地进行验收测试，例如用于验收测试驱动开发的成果，或者用于测试分布式异构应用程序中的各种接口。该框架的优势主要在于：关键字驱动测试可以重复利用、易扩展、支持生成 HTML 格式的测试报告、有庞大的测试库提供支撑等，但也存在着一些界面操作的共性问题，它会在测试用例过于庞大时产生界面卡顿，并触发一些 Bug，例如在导入测试库时会遇到界面卡死的现象。关于这两个框架的具体情况，我们将会在本书的第 3 章中为读者做详尽的专题介绍，希望能帮助读者掌握对任意一个基于 Python 环境的第三方框架的快速学习能力。

基本上，只要很好地掌握了 Selenium 和 Robot 这两个框架，那么无论是主流的、基于 Web 界面的自动化测试，还是面向其他 UI 的自动化测试，我们都能够获得一定的心得体会与实践经验，并且在日后的自我学习中举一反三，例如学习用于在 Android 和 iOS 平台上进行自动化测试的 Appium 框架，它的使用方法是大同小异的。这样一来，我们就能让自己在就业市场中占有一席地位。
