# 关于编程方法论及其推荐书目

如果读者经常参与一些线上的交流，就会发现一个普遍存在的问题，即人们在讨论计算机编程议题时实际上绝大多数都在讨论编程语言本身，例如，初学者应该先学习 C 还是 Java，Rust 或 Go 值不值得学习等议题。但在笔者看来，编程语言即使再重要，也只是语言文字对于人类思想的表达意义。举例来说，如果我想写一封情书，无论选择用英文写还是中文写，能解决的都只有如何精确地、有效地传递我对爱人的爱慕之情，决定这封情书核心质量的是我对爱人此时此刻的思恋，而不是文章本身用了欧美的十四行诗还是蝶恋花之类的宋词。编程工作也是如此，最终决定我们工作质量的是代码所要表达的编程思想。所以，当我们陷于一些诸如“Java 代码的执行性能很不好，用 C 编码才是永远的王道”之类的争论时，首先要搞清楚的是自己与争论对象想要表达的思想内容是否属于同一领域，不要和人吵了三天三夜之后发现对方是做跨平台终端应用的，自己是做 JVM 的，而 Java 这门语言也从来没被拿来实现 JVM 这样的中间件（这本来就是用 C 语言来实现的），这简直就和讨论“关公战秦琼谁会赢”一样毫无意义。

那么，究竟什么才是我们在编程时要表达的思想内容呢？在个人看来，它主要由用于宏观设计的方法论（Methodology）和用于具体实现的算法（Algorithms）两部分组成。在这篇文章中，我们会先聚焦于编程方法论的讨论，并以推荐书目的形式来为读者规划一个研究这一课题的路线图，以供参考。

## 编程方法论简介

在编程方法论（Programming Methodology）这一课题下，我们主要研究的是如何从宏观的角度来设计程序、构建程序这两个问题，其本质都是在探讨如何针对编程目标进行模块化设计。这里的模块化（Modularity），具体来说就是要探讨如何按照某个既定规则将要编程目标划分成若干个相对独立的部分，从而实现将整个编程过程分而治之的一种方法论。在该方法论之下，我们会默认计算机程序是由一系列模块组成的，这些模块之间通过一种被称之为“接口”的机制来实现相互联系，而我们实际要做的工作就是设计用于定义这套接口机制的规则。从 20 世纪 60 年代至今，围绕着对于接口机制的设计规则，业界陆续发展出了以下主要的编程方法论：

- **面向过程编程（Procedural programming）**：也被称作过程化编程，这是一种通过定义函数以及抽象数据类型的方式来实现模块化设计的编程方法。在该编程方法之下，程序的数据逻辑将通过抽象数据类型（Abstract Data Type，可简称 ADT）的方式来进行分组定义，而其接口机制的规则将通过一系列函数的定义来完成设计。面向过程编程主要常用于系统编程领域，代表性的编程语言主要包括 Fortran、Pascal、C 等。

- **面向对象编程（Object-oriented programming）**：这是一种在面向过程编程的基础上进一步执行抽象化设计的编程方法，它主张将之前的 ADT 及其相关的函数封装成一个被称为“对象（Objective）”的单位，然后以此为基础来完成针对编程目标的模块化设计。在该编程方法之下，被封装的 ADT 被称为对象的数据成员，它们就是被模块化了的数据逻辑，而被封装的函数则被称为对象的方法，它们实际上就是这些模块的接口。

  另外在上述模块化过程中，我们通常会选择将对象的封装动作抽象为一种被称作“类”的定义机制，以便于提高设计方案的可重用性与可扩展性。在这里，类与对象之间属于抽象与具象的关系，即类是对象的抽象化产物，而对象是类的具象化结果。面向对象编程是目前被使用得最为广泛的编程方法之一，主要用于应用层的编程，代表性的编程语言主要包括 Python、C#、Java 等。

- **函数式编程（Functional programming）**：也被称作函数程序设计，这是一种以λ演算规则为基础，将所有的计算机运算都视为函数运算，并且避免使用程序状态以及可变对象的编程方法。在该编程方法之下，我们的模块化设计是以函数为主要单位来完成的，这意味着在编写代码的过程中，一个函数既可以被当做输入给其它函数的参数，也可以用来充当从其他函数输出的返回值，并且随时可对它进行修改，或分配给一个指定的变量。

  与面向过程的编程方法相比，函数式编程更加强调程序执行的结果而非执行的过程，致力于倡导尽可能利用简单的执行单元来让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。也正因为如此，这种编程方法长期以来主要在学术圈流行，常用于计算机教学与科研工作，代表性的编程语言主要包括 Lisp、Erlang、Haskell 等。

## 面向过程的编程

## 面向对象的编程

## 面向类型的编程

## 面向表达式的编程

<!-- 以下为待整理的资料 -->

编程方法的演进之路

当下，我们认为程序是模块的集合，每个模块都有一系列用规范描述的接口。而规范是对模块预期行为的描述，它可以是用正式的数学语言编写的，也可以是非正式的。但不管这个规范是怎么编写出来的，它对模块行为的描述及其具体实现是相互独立的。例如对于一个排序程序来说，输入的数组和返回的结果应包含相同的元素，只是按照顺序重新排列了一遍。

对于模块，正确的实现是指提供了规范中指定的行为。所以当你审视一个模块的代码时，可以使用规范对代码进行推理。代码可能像排序程序一样很简单，也可能更复杂。一个模块可能会调用其他模块，即便如此，仍然可以通过本地推理（local reasoning）的方法来依次理解，因为你只需要关注某一模块。通过这种方式，我们实际上降低了开发一个复杂软件的难度。

回到1970年，我们了解了模块化的优点，了解了局部推理的重要性，但并不知道它具体是什么。通过模块化，一个团队中的成员就可以同时独立开发不同的模块。这样是便于修改的，一旦程序中的某些模块运行异常，可以用另外一个实现来替代它，整个系统的运行不会受到影响。

全局变量搞定一切——早期的结构化编程

在阅读了帕纳斯的论文[1]和其他文献后，我意识到自己在开发Venus操作系统时就发明了一种模块化机制，虽然当时并没有专门研究设计方法或编程方法，只是聚焦于能否构建出有效的软件。那时，我试图规避使用全局变量来组织代码的问题。

1958年诞生的ALGOL语言引入了块的概念，被认为是最早的结构化编程语言。ALGOL使用begin和end关键字表示代码的开始和结束，两个关键字中间的语句称为代码块，一个代码块可以嵌套在其他代码块中。在这种形式下，尽管内部块可以访问外部块的数据，但外部块却无法访问内部块的私有数据。所以为了实现块与块之间的通信，常见的方法是大量使用全局变量。—译者注

分区——模块化机制的雏形

我在设计Venus操作系统时使用了一种被称为“分区（partitions）”的概念。在Venus系统中，我将系统中已经存在的所有全局变量划分到不同模块中，每个模块都拥有一部分全局状态，并且禁止其他模块访问这些状态。但是同时，模块之间可以通过一系列方法与这些状态进行交互。这个想法的有趣之处在于它比其他人提出的模块化机制更有条理，因为这不仅仅是黑盒，它还有一个实际的接口结构（见图2）。所以我将其写了下来，并发表在ACM操作系统原理大会（SOSP）上[2]。

我发表的关于Venus操作系统的论文获了奖。在SOSP的演讲后，我被邀请到麻省理工学院（MIT）工作。这对我来说是一个很好的机会，因为编程方法是我热衷的研究方向。


Venus操作系统是芭芭拉博士毕业后在MITRE的第一个工作，她用微编程（microprogramming）设计并实现了一个机器架构Venus，并且在这个机器架构上构建了一个小型分时操作系统Venus。—译者注

从分区到抽象数据类型

1972年秋天，我在思考如何让程序员更容易理解论文中提到的想法。当程序员阅读一篇论文时，可能会觉得“哇，是的，就应该这么做，这个方法看起来很完美”。但是当程序员尝试将论文中的想法应用到自己的程序中时，一切都崩溃了，总觉得缺少了一些东西。我试图弄清楚缺少的究竟是什么。

几个月后我有了一个绝妙的解决办法─可以将分区联系到抽象数据类型（Abstract Data Type，ADT）。正如我们今天所知，抽象数据类型是指通过一系列方法为用户提供接口的对象，我们可以通过构造函数来创建对象，并通过一些方法与对象进行交互。所以当你观察一个分区时，就可以知道发生了什么。

我们通过创造抽象概念来设计模块，从而将模块化与设计联系起来。当我们考虑文件系统、设备驱动程序和I/O模块时，它们不仅仅是程序，还是一堆小模块的集合，数据抽象是一个比程序更大的概念。程序员理解数据类型和编程语言，他们明白这些实际上是抽象的，无法全部通过计算机的硬件功能来实现，只能通过软件的功能来达成。而且他们也能够通过编程来创造新的数据类型，所以这似乎是一个非常好的想法，但是要让它落地则需要编程语言的支持。正如我刚才所说，当时没有提供抽象数据类型的编程语言，所以我开始研究这个点。

我和史蒂夫·齐勒（Steve Zilles）一起工作，他是MIT的研究生也是IBM的员工。我们紧张地工作了几个月，其中一项工作就是再次阅读我们可以拿到的所有论文。在编程语言方面，我们已了解当时存在的大多数语言，诸如Fortran、COBOL、PL/I，同时更加清楚ALGOL在学术上的重要意义，我们进行了充足的技术储备。


詹姆斯·莫里斯(James H. Morris)写的论文“Protection in Programming Languages”[3]对我的工作影响很大。他在论文里提到了一个问题：“为了使局部推理起作用，我们必须遵循哪些规则？”正如我之前所说，局部推理对模块化非常重要，但我们并没有真正理解规则是什么。他在这篇论文中提到“模块外的代码不得修改由模块管理的数据”，这是很重要的一点，因为一旦外部代码可以修改模块内部的数据，你显然不可能通过本地推理验证模块代码是否正确。他还指出“基于模块的可修改性，外部的代码甚至不应该观察到内部的数据”。如果人们试图重新实现该模块，不需要对模块外的代码进行任何变动，将旧模块替换为新模块即可。通过每天的阅读和讨论，1973年夏末，我们已经对这个编程语言有了一个很好的构想，所以撰写了论文“Programming with Abstract Data Types”[4]。


这篇论文提出了数据抽象，以及对一种可以提供抽象数据类型概念的编程语言的需求。论文中提出将数据类型视为一组对象，它还有一系列操作，分别用于创建对象和使用对象，这些操作应是人们与模块交互的唯一方式。我们在论文中阐明：我们希望通过严格的检查来强制执行此规则。这篇论文包含了一种编程语言的构想。接下来，我决定设计并实现这个语言。这项工作主要与当时加入我小组的三位研究生（Russ Atkinson、Craig Schaffert和Alan Snyder）一起完成[5]。


这样做的意义是什么呢？首先，编程语言是一个数学对象，这意味着人们要针对正在发生的事情制定非常精确的规则。很多时候人们遇到麻烦的一个原因就是没有精确的规则。此外，编程语言是一种工具，只有人们实际使用它的时候，才能知道这个工具是否能解决问题。现在来看这似乎是顺理成章的，但在当时，能否拥有一种支持抽象数据类型、易使用且表现力强的编程语言是被怀疑的。当时的担忧之一是，随着编程语言的层次越来越高，程序员可能会无法实现他们想要的某些功能。当然，这个编程语言的性能必须够用。所以我们需要考虑这几个方面，以便拥有一个实用的工具。


文献[4]提出，对编程语言或系统来说，有效的保护机制至关重要，论文还从对象、局部变量、内存、访问控制等各层面来探讨保护原则。前文提到的抽象数据类型是指一个数学模型以及定义在该模型上的操作。它能够使人们独立于程序来理解数据结构的特性和作用。—译者注


从抽象数据类型到CLU


我们花了很长时间设计CLU，尝试了很多不同的方式。首先，我们必须想出一种实现抽象数据类型的技术，这就是我们所说的簇（cluster）。实际上，CLU的名字来源于cluster的前三个字母。簇与我们今天使用的类（class）很相似，但还包含其他方面的内容。数据抽象通常是集合（set）、列表（list）或树（tree）这样的集合，人们经常需要遍历一个集合并操纵里面的元素，比如打印一个集合中的所有元素。因此，我们必须找到一种简单的遍历机制，在不破坏集合中元素的同时对它们进行遍历。当时，编程语言中几乎没有异常处理机制，因为我们聚焦于正确性和规范，所以我们必须弄清楚异常处理机制是什么。通常情况下，程序无法对其合法参数的所有元素执行完全相同的处理，假设要从集合中选择一个元素，如果集合为空，人们会怎么做？众所周知，错误的来源通常远离产生错误的地方，所以当遇到这样的异常情况时，我们需要一个通用的异常处理机制。最重要的是，当时的编程语言不支持我们需要的多态或泛型，所有的语言都只提供几种内置类型。因此，如果要编写一个对整数数组进行排序的程序，则必须编写另一个程序对字符串数组进行排序。人们每发明一种数据类型，都必须重新实现所有代码，所以我们需要一个通用的机制来规避这个问题。此外，数据类型本身必须是通用的。所以我们发明了CLU这个编程语言，并在1977或1978 年左右将其推广。后来我们有了一个可以运行的CLU编译器。很快这个编程语言就有了一批用户，我们证明了人们可以拥有一种具有数据抽象的语言，并取得了良好的反响。


CLU远远领先于它所处的时代。这不仅仅因为它有数据抽象而其他编程语言没有，而且CLU中的模板、异常处理机制、迭代器和多赋值等在今天看来很普遍的概念和功能，在当时的编程语言中并不存在。因此，CLU也启发着之后的编程语言的设计，如C++、Java和Python等。—译者注

CLU之后

发明了CLU之后，我试图弄清楚下一步要怎么做。我读了互联网的发明者之一鲍勃·卡恩（Bob Kahn）的一篇论文，在这篇论文中，卡恩谈到了他对分布式计算的构想。在分布式计算中，人们可以调用同一个网络中的所有程序，不管具体是在哪一台机器上运行，但当时没有人知道这一点要如何实现，而这正是我所要解决的问题。在CLU的设计中我没有考虑并发的问题，这是为了保证设计处于可控状态。但在分布式领域中，我可以重新考虑并发机制。所以在我接下来的职业生涯中主要从事分布式计算的工作。


但我并没有失去对编程方法论的兴趣。实际上我在MIT设计一门课程时，在模块化程序设计、正确性推理等方面也做了很多工作。这其中的大部分是与约翰·古塔格（John Guttag）共同完成的，我们发表了几篇关于这项工作的论文，并编写了一本教科书Abstraction and Specification in Program Development[6]，使用CLU作为编程语言。后来我们写了一本使用Java作为编程语言的书。


芭芭拉在开发CLU语言时并没有考虑并发性，因为当时CLU的功能已经足够多了，并且考虑并发会分散注意力。后来，当她开始从事分布式计算工作时，就需要再次考虑并发这个问题。在70年代后期，虽然芭芭拉开始研究分布式计算，但她一直在思考“如何推理（reason about）抽象数据类型的正确性”“如何为抽象数据类型编写规范”等问题。—译者注


从CLU到面向对象编程


我今天还要谈论我在编程方法论方面所做的一些其他工作——类型层次结构（type hierarchy）。1987年，我被邀请在面向对象编程语言会议（OOPSLA）上作一个主题演讲，我可以借机去了解SmallTalk和其他衍生语言有什么新的进展，因为我要考虑面向对象编程，它混合了抽象数据类型和继承等思想。我阅读了关于SmallTalk和一大批提供了继承机制的文献。继承是作为一种技术实现开始的。当人们已经有一个承担某项功能的类，但还想要一个子类来承担相似但不相同的功能时，可以通过借用超类来实现这个功能。虽然许多论文谈论的具体内容略有不同，但它们都将其归纳为类型层次结构。我们的问题是，当编写需要超类对象的代码时，它可能会在参数中接收子类的对象。那些文献的作者试图弄清楚这意味着什么，因此，他们将子类的对象视为超类对象的子类型。


我发现那些论文的作者对于类型层次结构不是很理解。我记得有一篇论文说“堆栈和队列都是彼此的子类型”，这显然不对。设想如果你编写一些需要堆栈的代码，但最后收到的却是一个队列，即你期望的是后进先出（Last In First Out，LIFO）的行为，但你得到的却是先进先出（First In First Out，FIFO）的行为，你的代码则不太可能正常工作。


在1987年7月的演讲中，我对行为子类型（behavioral subtyping）做了一个简单的定义。如果使用超类方法，子类型对象的行为应该与超类型对象的行为一样。在这种约束方式下，子类型必须与超类型相同。1988年，ACM SIGPLAN Notices邀请我将其写下来。后来，我与周以真 （Jeannette Wing）共同对工作进行了梳理，并对正在发生的事情提出了正式定义。


这后来被称为Liskov替换原则（Liskov Substitution Principle）。这是一个非常重要的概念，从“behavioral subtyping”的语义上来看，虽然里面有“行为”这个词，但我真正谈论的是规范。如果人们考虑模块化，就可以根据这些规范来证明一个模块支持着另外一个模块，最后，人们就可以证明这个实现运行正常。


由于芭芭拉发现很多人并未真正的理解超类和子类的意义，所以在这次演讲中她给出了一个非正式的定义：子类应该在使用超类方法的时候表现得如同超类一样[7, 8]。—译者注

总结

我今天一直在谈论模块化以及该概念的发展历程。当我获得2008年ACM图灵奖时，我发现我的学生并不了解在有数据抽象这个概念之前编程是如何进行的。我丈夫每天都在网上浏览关于我获得图灵奖的评论。他看到了一条看上去不那么友好的评论：“她凭什么获奖?每个人都知道这个。”说此话的人本意并不是批评我，实际上这是一种巨大的赞美，因为基于我和我团队的工作，基于在编程语言和编程方法领域的共同努力，我们探索出了今天构建软件的方式。这就是为什么当下编程的方式是基于抽象的模块化。
