# CSS学习笔记

CSS（即Cascading Style Sheets的英文缩写，在中文里通常被译为“层叠样式表”）是一门用于为HTML或XML文档定义外观样式的计算机标记语言。对于这门语言，我们首先要了解的是，它不是一门能单独使用的计算机语言，它必须与HTML或XML这一类用于描述文档结构的标记语言一起协同工作。除此之外，它还可以配合各种脚本语言动态地对HTML或XML文档中的各元素进行格式化，对它们的位置和显示范围进行精确地控制。在这篇笔记中，我们将主要介绍在网页设计中使用的CSS技术，下面先来介绍一些基本概念。

## 基本概述

在网页设计工作中，HTML和CSS这两门标记语言有着明确的分工，HTML负责确定网页的文档结构及其要显示的内容（关于这方面，读者可参考我的[[HTML 学习笔记]]），而CSS则负责确定以何种外观来展现这些内容，例如，CSS可用于设置网页的整体布局、图文排版、交互界面等，并且这些设置一经完成就可以被反复使用。

CSS技术的出现对网页设计工作的最大贡献之一，就是让设计师们得以将网页中的内容与它要呈现的方式分开。毕竟，在CSS技术出现前，设计师们在使用HTML定义网页的文档结构和内容时还必须要指定内容的呈现外观，如今很少用到的`<font>`、`<b>`、`<i>`等HTML标记就是那时候的产物。这些标记主要用于设置字体的颜色、背景色、大小、字形以及排列方式等。例如在HTML语法中，`<h2>`标记用于定义二级标题，它在级别上比一级标题低，比三级标题高。这些信息都是结构上的信息。但假如读者要更改二级标题的颜色、字形、大小的话，在没有CSS技术的时代，他就得要使用`<font>`这样的标记了，光靠`<h2>`是不够的，因为后者只是一个用于表示文档结构的标记。例如，如果我们想让二级标题使用白底红字的斜体字，就需要这样写：

```html
<h2><font color="red" bgcolor="white"><i>二级标题</i></font></h2>
```

上面这种样式设置的方法最大的问题是，它只针对单一具体的页面元素有效，因此相同的样式通常需要在不同的页面元素上反复设置，这会大大增加HTML代码的冗余度，从而导致整个网页文档变得非常臃肿和混乱，难以维护。因为如果以后想更改二级标题的样式，就必须在网页文档中找到所有用到`<h2>`+`<font>`标记的地方，然后逐一修改。CSS技术出现后，这些问题就迎刃而解了，因为这项技术允许设计师们将文档结构和内容从外观样式中分离出来，从而让他们可以专注于文档结构的定义，而将外观样式的定义交给CSS技术。例如对于上面这个例子来说，设计师们如今只需要使用HTML的`<h2>`标记设置网页的内容结构，而内容的显示样式则用CSS设置，这样一来，上面的HTML代码就可以被修改成这样：

```html
<h2>二级标题</h2>
```

然后，设计师们只需要在对应的CSS样式表文件中将二级标题的样式设置为白底红字的斜体字，具体代码如下：

```css
h2 {
    color: red; 
    background: white; 
    font-style: italic;
}
```

对于上述代码中使用的具体语法，我们稍后再做具体介绍。在这里，读者暂时只需要理解：由于CSS的出现，我们实现了HTML/XML文档的内容结构与其外观样式的解耦合。从此之后，HTML就只负责定义网页的结构与内容，则CSS复杂定义网页的显示方式，包括颜色、字形、排列、大小以及面向不同显示设备的自适应能力等。

当然了，CSS样式表的“层叠”特性也赋予了它非常灵活的使用方式。CSS代码它既可以被保存为一个独立的文件，也可以被内嵌在特定的HTML文档内，浏览器会自行根据样式的载入顺序来决定网页最终的外观。甚至，设计师们还可以选择先针对同一份HTML/XML文档定义多个CSS样式表文件，然后让浏览器根据动态脚本的设定来决定网页要使用的样式。这样一来，设计师们就可以为不同的显示设备设计不同的CSS样式表了，例如，他们可以让HTML文档在计算机屏幕上的显示与其在打印机中的输出效果略有不同，以便让它在不同的设备中都能有更好的显示方式。总而言之，CSS技术赋予了设计师们更强大的外观设计能力。

## 发展历程

CSS技术最初由Netscape公司发明，后来被W3C组织标准化，并最终成为W3C组织标准的一部分。下面，我们将照例为读者简单介绍一下这项技术从无到有，并最终实现标准化的发展历程。

### 启蒙时代

正如之前所说，HTML规范中虽然规定了标题、段落应该使用的标记，但并没有对这些内容在网页浏览器中的呈现方式做出明确的规范。因此，为了满足日益增长的万维网访问需求，各大网页浏览器在1990年代初那段时间里都各自为它们的用户提供了不同的样式表技术，然后让用户自行使用这些技术来决定网页的呈现方式。换而言之，样式表技术最初是作为浏览器的特定功能直接提供给用户，毕竟早期的HTML文档中能呈现的元素很少，用户完全有能力自行定制该文档的呈现样式。

到了1993年，Robert Raisch在www-talk的邮件列表中曾经提出过一个关于通用样式表的提案，他在该提案中首次提出了一套易于被浏览器解析，且能与HTML文档一起发布的样式表编写规则。这套规则被命名为“RRP”，其定义网页样式的代码大致如下：

```rrp
@BODY fo(fa=he,si=16)
```

上面这段代码的作用是在将字体（`fa`，即font family）设置为`he`（即helvetica），字号（`si`，即font size）设置为`16`像素。现在的人一定会觉得这段代码中的语法单元过度使用了缩写，可读性和可维护性都很差，但在没有gzip，且平均网速只有`14.4k`的时代，尽力压缩代码的体量，以便减少样式表文件在网络传输过程中所需要的时间是非常必要的措施。RRP作为一套通用化的样式表规则，最大的问题还是缺少一个明确的尺寸单位，浏览器对代码中数字使用的单位得根据它们所在的上下文来判断（例如字体大小都以像素为单位）。这也让RRP看起来更像是“一系列指导渲染的指示或者建议”，它最大的价值是提出了让同一份样式表在命令行浏览器和图形界面浏览器中都能正常工作。另外值得一提的是，RRP并不支持如今样式表技术中的“层叠”特性，即一个HTML文档在同一时刻只能激活一个样式表。

令人遗憾的是，Mosaic浏览器在当时并没有采用这一通用化的样式表规则，而是选择了直接使用HTML提供的样式类标记（即之前提到的`<font>`、`<b>`、`<i>`等标记）。需要特别说明的是，1993年发布的这个Mosaic浏览器是万维网历史上第一个可以在网页中显示图片元素的浏览器，它也是日后大名鼎鼎的Netscape Navigator浏览器的前身。

![Mosaic浏览器](./img/html&css/11.png)

另一方面，来自台湾的魏培源在更早些时候也开发了一款名叫“ViolaWWW”的浏览器（这款浏览器被认为是万维网历史上第一款被广泛使用的图形化界面的网页浏览器，并一度成为了Mosaic浏览器的强劲对手）。该浏览器的作者也曾经提出过一套通用的、支持嵌套式结构的样式表编写规则。这套规则被命名为PWP，其代码编写方式大致如下：

```pwp
(BODY fontSize=normal
      BGColor=white
      FGColor=black
  (H1   fontSize=largest
        BGColor=red
        FGColor=white)
)
```

上述代码的作用就是分别为`<body>`和`<h1>`标记定义的页面元素设置了字体大小、颜色与背景色。PWP的代码可读性显然比RRP好了许多，大部分开发者一眼就可以看出它与如今的CSS语法规则已经非常接近了。特别值得一提的是， PWP也是万维网历史上第一个允许HTML文档利用`<link>`标记从外部加载样式表文件的技术，这也对后来的CSS产生了深远的影响。同样令人遗憾的是，采用了这项样式表技术的ViolaWWW浏览器只能在X Window System下工作，而后者只在 Unix 系统上受欢迎。当Mosaic浏览器被成功移植到到Windows后，ViolaWWW浏览器就组件失去了竞争优势，并最终消失在了历史中。

![ViolaWWW浏览器](./img/html&css/12.png)

然后到了1994年，Håkon W Lie提出层叠HTML样式表（Cascading HTML Style Sheets，CHSS）。CHSS既支持用户自定义样式表，也支持网页作者样式表，而且可以满足不同规则以百分比的方式组合使用。它的权重规则计算方式不够直观，当不同规则混合时会得到什么实际效果并不容易从代码中看出。1996年，出现了与CSS语法很像的表现指明语言（Presentation Specification Language，简称"PSL 96"）。PSL 96除表达样式外，也支持条件判断等功能，还可根据对浏览器信息的判断来使用不同的样式，但未获得青睐。

### 诞生与发展

1994年，W3C组织宣布成立，该组织主要致力于各种万维网技术的标准化，其中的主要任务之一就是制定一套通用的样式表规范。哈肯·萊和伯特·波斯是W3C的成员，他们与当时正在设计Mosaic浏览器的网景公司（Netscape）合作，共同设计出了CSS的第一个版本。哈肯·萊是Mosaic浏览器的开发者之一，而伯特·波斯是网景公司的首席技术官。在这两位的影响之下，W3C特别针对CSS的发展组织了一次讨论会。哈肯、波斯和其他一些人（比如微软的托馬斯·里尔登）是这个项目的主要技术负责人。

1996年12月，哈肯·萊与伯特·波斯发布了CSS规范的第1个版本，这一版的规范来也被哈肯·萊写进了自己的博士论文。令人遗憾的是，由于当时主流的网页浏览器所采用的内核架构完全不适合解析CSS的语法，再加上那个时候的设计师们还习惯于滥用HTML中的样式类标记（即之前提到的`<font>`等标记），且漠不关心代码校验，所以CSS技术真正流行起来还得等到若干年之后。

1998年，网页浏览器市场份额被微软公司的Internet Explorer（即IE浏览器）和网景公司的Netscape Navigator两大浏览器巨头所占据。自CSS出现后，IE浏览器虽然走在了逐步实现CSS第1版标准的前列。但因为微软公司后来不重视问题修补，导致遗留Bug很多，这也使得该浏览器长期为人们诟病。而网景公司则把重心放在了网页脚本语言的开发上，但很快被微软模仿。网景在90年代末和微软展开的浏览器大战中最终一败涂地，走向破产边缘，但网景也成功推出了日后广泛流行于网页设计中的JavaScript语言。浏览器大战使得网页设计人员深受其害，因为不同浏览器支持的语法规则不太一样，网页设计人员不得不为IE浏览器和网景浏览器分别各设计一套网页。为了解决这一问题，新成立的民间设计人员团体“网页标准计划（WaSP）”开始在网络舆论场上致力于将W3C的建议宣扬为标准，并持续向还未加盟W3C标准的浏览器开发商施加压力。

事实上早在1997年初，W3C就已经组织了专门管CSS的工作组，其负责人是克里斯·里雷。这个工作组开始讨论第1版中没有涉及到的问题，其工作成果就是在1998年5月出版的第2版规则。为了推广这一标准，WaSP的7位成员成立了“CSS武士团（CSS Samurai）”，专门致力于劝说Opera浏览器和IE浏览器解决在支持CSS方面存在的诸多问题。除此之外。WaSP也积极劝说网景公司和Macromedia公司分别改进其产品对CSS标准的支持。

2003年，Dave Shea推出了一个名为“CSS禅意花园（CSS Zen Garden）”的站点，向人们展示出仅通过应用不同页面样式规则，就可以实现对网页艺术风格的焕然一新。这个网站在网页设计相关人群中产生了不小影响。然后从2006年到2009年，这种“DIV+CSS”网页布局方式逐步了取代缺乏灵活性的传统表格布局，无表格网页设计成为解决网页布局问题的主流方案。虽然这一方案后来也导致了网页设计界出现了一些为了跟风而滥用`<div>`布局的情况，比如将`<h1>`和`<h2>`等本身已有语义的标签也改用`<div>`标签替代。但CSS技术在网页设计中的地位也因此得到了最终的确立，成为了网页设计师们必须掌握的核心技术。

### 标准化历程

下面，让我们用一张表格来具体地整理一下CSS技术所走过的标准化历程，及其每一版规范所添加的内容。

| 年份 | CSS版本 | 标准化组织 | 描述 |
|------|---------|-----------|------|
| 1996 | CSS 1    | W3C       | CSS 1是第一个CSS标准版本，定义了基本的样式属性和选择器。 |
| 1998 | CSS 2    | W3C       | CSS 2扩展了CSS1的功能，引入了浮动、定位、背景、字体等新特性。 |
| 2001 | CSS 2.1  | W3C       | CSS 2.1是对CSS2的修订版本，解决了一些CSS2规范中的错误和模糊之处。 |
| 2005 | CSS 3    | W3C       | CSS 3是一个模块化的标准，将CSS分为多个模块，每个模块独立发展。 |
| 2011 | CSS 4    | 无        | CSS 4并没有成为官方标准，而是将新特性分为CSS模块级别的工作草案。 |
| 2017 | CSS Grid Layout | W3C | CSS Grid Layout引入了一种新的布局方式，可以创建复杂的网格布局。 |
| 2019 | CSS Scroll Snap | W3C    | CSS Scroll Snap定义了滚动容器的分割点，使得滚动更加精确和流畅。 |
| 2021 | CSS Contain | W3C       | CSS Contain提供了一种优化CSS性能的方式，通过限制样式的影响范围。 |

在这篇笔记中，我们介绍所有的内容都将主要基于CSS 3这一版最新的官方标准来展开。该标准新增了圆角效果、渐变效果、图形化边界、文字阴影、透明度设置、多背景图设置、可定制字体、媒体查询、多列布局以及弹性盒模型布局等诸多更为丰富的新样式特性，这将有助于我们设计出更为丰富多彩的网页。

## 基本语法规则

在CSS 3标准所规范的样式定义语法中，一段完整的样式表代码通常由一系列样式规则语句组成，而每个样式规则语句的定义则主要由选择器、属性名称和属性值三个语法单元，以及在必要时才会添加的代码注释组成，其具体形式大致如下：

```css
[选择器1] {
    [属性名称1]: [属性值1];
    [属性名称]2: [属性值2];
    [属性名称3]: [属性值3];
    /* 注释：同一样式规则语句中可设置多个样式属性 */    .
    [属性名称n]: [属性值n];
}
[选择器2] {
    [属性名称1]: [属性值1];
    [属性名称]2: [属性值2];
    [属性名称3]: [属性值3];
    [属性名称n]: [属性值n];
}
/* 注释：同一CSS文件中可包含多条样式规则语句 */
[选择器n] {
    [属性名称1]: [属性值1];
    [属性名称]2: [属性值2];
    [属性名称3]: [属性值3];
    [属性名称n]: [属性值n];
}
```

下面，让我们来详细介绍一下上述语法规则中使用到的语法单元及其各自的编写方式。

### 选择器

`[选择器]`作为样式规则语句的第一部分，主要作用是在HTML元素与CSS样式规则之间建立对应关系，以便对指定的HTML元素应用该选择器后面所定义的样式规则。而根据选择HTML元素的方式，CSS选择器可以被划分成几个不同的种类。只有切实地了解了这些不同种类的选择器，读者才能更容易正确得使用它们。接下来，我们先来介绍几种在网页设计工作中会用到的基本选择器。

- **基于标记名的选择器**：这种CSS选择器通常被称为*元素选择器*，主要用于匹配其关联HTML文档中的所有指定名称的标记，它的语法是最简单的，只需直接指定要匹配的标记名称即可。譬如，下面是一些元素选择器的简单示例。

    ```css
    h1 { /* 匹配文档中所有的一级标题元素 */
        color: blue;
    }
    ```

- **基于id属性值的选择器**：这种CSS选择器通常被称为*ID选择器*，主要用于匹配其关联HTML文档中的所有设置了特定`id`属性值的标记，语法格式为：`#ID值`。譬如，下面是一些ID选择器的简单示例。

    ```css
    #card { /* 匹配文档中所有 id=“card” 的元素 */
        color: blue;
    }
    #user { /* 匹配文档中所有 id=“user” 的元素 */
        color: blue;
    }
    ```

- **基于class属性值的选择器**：这种CSS选择器通常被称为*类选择器*，主要用于匹配其关联HTML文档中的所有设置了特定`class`属性值的标记，语法格式为：`.类名`。譬如，下面是一些类选择器的简单示例。

    ```css
    .box { /* 匹配文档中所有 class=“box” 的元素 */
        color: blue;
    }
    .video { /* 匹配文档中所有 class=“video” 的元素 */
        color: blue;
    }
    ```

- **基于标记+属性的选择器**：这种CSS选择器通常被称为属性选择器，主要用于匹配其关联HTML文档中的包含指定属性的特定标记，语法格式为：`标记名[属性名{=属性值}]`，其中`{=属性值}`的部分可以省略。譬如，下面是一些属性选择器的简单示例。

    ```css
    /* 匹配<a title="属性值">这个标记，这里的“属性值”可是任意字符串 */
    a[title] { 
        color: blue;
    }
    /* 匹配<a href="https://example.com">这个标记 */
    a[href="https://example.com"] {
        color: blue;
    }    
    ```

- **基于标记+伪类的选择器**： 这种CSS选择器通常被称为伪类选择器，这主要是因为其用法与之前介绍的类选择器非常类似，只不过它匹配的不是明确指定了`class`属性的HTML标记，而是指定标记的某个特定状态或子结构，语法格式为：`标记名:伪类名`，其中的`伪类名`代表的就是被指定标记所定义元素的某个状态或子结构。譬如，下面是伪类选择器的一些简单示例。

    ```css
    a:hover { /* 匹配鼠标指针悬浮到超链接元素上时的状态 */
        color: blue;
    }
    a:active { /* 匹配超链接元素被激活时的状态 */
        color: blue;
    }
    a:visited { /* 匹配超链接元素被访问过的状态 */
        color: blue;
    }
    p:first-child { /* 匹配段落元素中的第一个子标记 */
        color: blue;
    }
    p:last-child { /* 匹配段落元素中的最后一个子标记 */
        color: blue;
    }
    p:nth-child(2) { /* 匹配段落元素中的第二个子标记 */
        color: blue;
    }
    p:nth-last-child(2) { /* 匹配段落元素中的倒数第二个子标记 */
        color: blue;
    }
    ```

- **基于特定标记+伪元素的选择器**：这种CSS选择器通常被称为伪元素选择器，主要用于匹配某个指定标记的某个部分而不是全部，语法格式为：`标记名::伪元素名`，其中的`伪元素名`代表的就是被指定标记中的某个特定部分。譬如，下面是伪元素选择器的一些简单示例。

    ```css
    p::first-line { /* 匹配段落元素中的第一行 */
        color: blue;
    }
    p::last-line { /* 匹配段落元素中的最后一行 */
        color: blue;
    }
    p::selection { /* 匹配用户选中或高亮显示的文本 */
        color: blue;
    }
    p::before { /* 匹配段落元素之前插入的内容 */
        content: "Hello, ";
    }
    p::after { /* 匹配段落元素之后插入的内容 */
        content: "!";
    }
    p::first-letter { /* 匹配段落元素中的第一个字母 */
        color: blue;
    }    
    ```

### 样式设置

在之前提到的CSS语法规则中，`[选择器]`以外的内容都可被称为“样式设置”部分，这部分通常由一系列格式为`[属性名称]:[属性值]`的语句构成，下面继续来介绍一下这两个语法单元：

- **属性名称**：`[属性名称]`的作用是指定被设置样式的具体项。在CSS代码中，一段样式定义可以指定的具体项取决于`[选择器]`单元所匹配的页面元素，例如，对于`<header>`、`<nav>`这样的布局类元素来说，设计师们可以为它们设置以下常见的样式项：
  - `height`：设置页面元素的垂直高度；
  - `width`：设置页面元素的水平宽度；
  - `margin`：设置页面元素的外边距；
  - `padding`：设置页面元素的内边距；
  - `font-size`：设置页面元素中文本的字体大小；
  - `border`：设置页面元素的边框；
  - `color`：设置页面元素中文本的字体颜色；
  - `background-color`：设置页面元素的背景颜色；

- **属性值**：`[属性值]`的作用是为`[属性名称]`所指定的样式项目设置具体的值，它的取值类型和范围取决于它要设置的`[属性名称]`，例如：
  - 对于`height`、`margin`之类的、与尺寸问题相关的`[属性名称]`，它的取值就是以`px`、`em`或`%`为单位的数字；
  - 对于`background-color`这种与颜色相关的`[属性名称]`，它的取值就是Hex、RGB之类的颜色编码，或者CSS预定义的颜色名称；
  - 对于`background-image`这种与多媒体文件相关的`[属性名称]`，它的取值就是用于表示该文件所在位置的字符串；

### 代码注释

在CSS语法中，用于注释的语法单元通常以`/*`开始，以`*/`结束。它主要用于*在某段CSS代码的作用隐晦不明时*对其进行文字说明，以便增强代码的可读性，并不会被网页浏览器渲染。例如在之前那个用于示范布局类HTML标记的示例中，我们基于教学目的将它的CSS样式代码注释如下：[^1]

[^1]: 具体可参考本笔记文件所在目录下的`examples/layoutCase`目录中的示例。
  
```css
/* 只有`:root`伪类选择器的自定义属性可被全局使用，
 * 一般选择器的自定义属性只能在被其匹配的元素中使用
 */
:root {
    --primary-bg-color: rgb(164, 205, 223);
}

/* 为了在后续代码中顺利使用相对尺寸单位，
 *  在这里必须要先利用html根标记的选择器建立一个基准
 */
html {
    /* 将网页的基准高度设置为浏览器的视口高度*/
    height: 100%; 
    /* 将网页的基准宽度设置为浏览器的视口宽度 */
    width: 100%;
    /* 设置网页使用的默认字体大小为16个像素单位*/
    font-size: 16px;
}

/* 匹配body标签，用于定义整个网页所在区域的样式 */
body {
    /* 设置被匹配标签所在元素的高度：为网页基准高度的90% */
    height: 90%;
    /* 设置被匹配标签所在元素的背景色 */
    background-color: var(--primary-bg-color);
    /* 设置被匹配标签所在元素的内边距 */
    padding: 1vh 0.5vw;
}

/* 匹配header标签，用于定义网页头部区域的样式 */
header {
    height: 5%;
    background-color: white;
    padding: 1.5vh;
    font-size: 1.5rem;
    text-align: center;
    border: 1px solid;
}

/* 匹配nav标签，用于定义网页导航栏区域的样式 */
nav {
    height: 5%;
    background-color: white;
    padding: 1.5vh;
    border: 1px solid;
    font-size: 1.5rem;
    text-align: center;
}

/* 匹配main标签，用于定义网页主要内容区域的样式 */
main {
    height: 80%;
    background-color: white;
    margin: 0.5vh 0;
    padding: 1vh 0.5vw;
    font-size: 1.5rem;
    border: 1px solid;
    text-align: center;
}

/* 匹配section标签，用于定义网页主体区域的样式 */
section {
    height: 85%;
    background-color: white;
    margin: 0.5vh 0vw;
    padding: 1vh 1vw;
    font-size: 1.3rem;
    border: 1px solid;
    text-align: center;
}

/* 匹配aside标签，用于定义网页侧边栏区域的样式 */
aside {
    float: left;
    height: 90%;
    width: 20%;
    background-color: var(--primary-bg-color);
    margin: 1.5vh 1.5vw;
    padding: 0.5vh 0.5vw;
    border: 1px solid;
    font-size: 1.3rem;
    text-align: center;
}

/* 匹配article标签，用于网页中某一特定内容区域的样式 */
article {
    float: left;
    height: 70%;
    width: 70%;
    background-color: var(--primary-bg-color);
    margin: 1.5vh 0.5vw;
    padding: 1.4vh 0.5vw;
    border: 1px solid;
    font-size: 1.3rem;
    text-align: center;
}
/* 匹配article标签下的h1标签 */
article h1 {
    background-color: white;
    margin: 1.5vh 0.5vw;
    padding: 0.5vh 0.5vw;
}
/* 匹配article标签下的p标签 */
article p {
    height: 75%;
    background-color: white;
    margin: 1.5vh 0.5vw;
    padding: 0.5vh 0.5vw;
}

/* 匹配footer标签，用于定义网页底部区域的样式 */
footer {
    height: 5%;
    background-color: white;
    padding: 1vh 0.5vw;
    border: 1px solid;
    font-size: 1.5rem;
    text-align: center;
}
```

以上就是CSS的基本语法，我们可以利用这套语法来创建一系列样式规则，以便完成对页面元素的外观设计。除此之外，CSS的强大之处还在于它的层叠性，这意味着网页设计师们可以使用不同的、可相互叠加的CSS样式规则来控制元素的外观，从而实现复杂而精致的网页设计效果。

## CSS要解决的问题

在使用CSS定义网页样式的过程中，设计师们很大一部分的工作都与尺寸和配色问题有关，因为这两个问题涉及到如何在网页中呈现整体布局、图文信息以及用户交互界面等元素。下面先来介绍在网页设计工作中首先要解决的布局问题。

### 网页布局问题

在网页设计工作中，页面中各元素的布局安排是设计师们首先要解决的一个关键问题，因为这直接关系到布局类元素、图文类元素、用户交互类元素在网页上的具体位置与呈现范围，以及这些元素彼此之间的距离。为了解决好这个关键问题，设计师们需要先了解一下相关的基本概念。

#### 网页中的尺寸概念

在网页设计过程中，设计师们需要先了解一些与尺寸相关的概念，因为这些概念在网页布局过程中会起到关键作用，其重要性就相当于画家在开始作画时的构图作业。下面，我们就来具体介绍一下这些概念：

1. **像素**：这一概念是计算机显示设备中的基本度量单位，这一单位最初来自于计算机显示设备上可显示的物理光源。换而言之，在与计算机显示设备相关的领域中，一个像素就代表一个显示单元，像素的大小很大程度上代表了设备的分辨率。
2. **分辨率**：这一概念主要用于量化显示设备（如计算机显示屏、手机屏幕等）所显示图像的精细程度，它的具体表达形式是`[水平分辨率]x[垂直分辨率]`。其中，`[水平分辨率]`是显示设备在水平方向上可显示的像素单位，而`[垂直分辨率]`则是它在垂直方向上可显示的像素单位。例如，如果某个显示设备在水平方向上可显示1920个像素单位，在垂直方向上可显示1080个像素单位，那么该设备的分辨率就可以被表示为`1920x1080`。
3. **视口**：视口这一概念主要指的是用户在网页浏览器中看到的有效可视区域，即浏览器窗口中刨除菜单栏、工具栏、侧边栏等软件本身的界面元素之外，真正用于显示网页内容的那个区域。每个浏览器都有自己不同的有效可视区域。在网页设计工作中，设计师们需要根据这些不同的视口尺寸来进行网页设计工作，以确保网页中显示的内容在各种视口尺寸上都能适应良好。
4. **布局尺寸**：这一尺寸概念主要用于确定网页中各个元素的相对尺寸和位置，其中的设置对象包括布局元素、文本标题与段落、图像、视频播放器等。在CSS代码中，设计师们通常会使用相对长度单位来设置这些元素在不同设备屏幕上的尺寸，以提高它们的适应性。
5. **字体尺寸**：这一尺寸概念主要用于确定字体在网页中的大小。在CSS代码中，设计师们通常使用相对长度单位来设置合适的字体大小，以确保网在不同设备屏幕上的可读性。
6. **内外边距尺寸**：这一尺寸概念主要用于设置网页中各元素内侧与外围的空白区域。在网页设计工作中，设计师们通常需要确保网页中存在着一些合理的空白区域，以提升网页的布局效果及其可读性。
7. **图像的尺寸及分辨率**：这一尺寸概念对于确保网页中的图像能适应不同的设备屏幕是至关重要的。在网页设计工作中，设计师们通常会使用响应式图像完成网页中与图像有关的设计，本书将会在下一章的项目中具体演示这部分知识的应用。

只要能综合利用好上述概念，网页设计师们就可以设计出能适应不同显示设备的网页，确保这些网页在多种设备与网页浏览器上都能够呈现出符合设计意图的视觉效果。为了能更好地实现这一目的，本书在这里建议读者尽可能使用以下相对长度单位来设置网页中的尺寸。

- `px`：这是CSS代码中使用的像素单位，它既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念，因此在CSS代码中使用像素概念时务必要考它具体的运行环境。默认情况下，一个CSS像素应该等于一个物理像素的宽度。但在一些像素密度较高的显示设备上，一个CSS像素单位也有可能相当于多个物理像素的尺寸；
- `em`: 这是CSS代码中基于网页浏览器中默认字体高度的相对尺寸单位，由于目前主流网页浏览器的默认字体高度为`16px`，所以通常可以认为`1em`等于`16px`；
- `rem`：这是CSS代码中基于当前网页根元素（即`<html>`标记对应的元素）的字体高度来使用的相对尺寸单位。当然，在使用该尺寸单位之前，设计师们必须先确当前网页的根元素对字体高度做了明确的设置；
- `%`：这是CSS代码中当前元素相对于其外层元素的尺度单位，通常用于设置网页中布局尺寸的设计，当然了，在对当前元素使用这个尺度单位之前，设计师们必须先确保其外层元素的相关尺寸已经得到了明确的设置；
- `vm`：这是CSS代码中相对于浏览器视窗宽度的尺度单位，换而言之，`1vw`等于浏览器视窗宽度的`1%`;
- `vh`：这是CSS代码中相对于浏览器视窗高度的尺度单位，换而言之，`1vw`等于浏览器视窗高度的`1%`;

#### PC端的网页布局

#### 移动端的网页布局

具体到在为移动端设备设计网页时，设计师们还需要更进一步考虑如何让网页动态适配各种大小不一的显示设备。正如读者所知，Apple、Google、三星以及华为等各大移动设备制造商如今在设备屏幕上的设计方案可谓是八仙过海、各显神通，且不说不同设备制造商之间产品的屏幕参数各不相同，就连出自同一设备制造商在每一年推出同品牌同系列的产品时的屏幕设计方案也都会存在些许差异。例如在下表中，我们可以看到当前一些主流品牌系列的手机屏幕情况：[^2]

| 设备名称                       | 操作系统 | 尺寸 (英寸) | 纵横比   | 分辨率（px）    |
| ------------------------------ | -------- | ----------- | -------- | -------------- |
| iPhone 12 Pro Max              | iOS      | 6.7         | 19 : 9   | 1284 x 2778    |
| iPhone 12 Pro                  | iOS      | 6.1         | 19 : 9   | 1170 x 2532    |
| iPhone 12 Mini                 | iOS      | 5.4         | 19 : 9   | 1080 x 2340    |
| iPhone 11 Pro                  | iOS      | 5.8         | 19 : 9   | 1125 x 2436    |
| iPhone 11 Pro Max              | iOS      | 6.5         | 19 : 9   | 1242 x 2688    |
| iPhone 11                      | iOS      | 6.1         | 19 : 9   | 828 x 1792     |
| iPhone SE（SE, 5S, 5C）        | iOS      | 4.0         | 16 : 9   | 640 x 1136     |
| Google Pixel 3,Lite            | Android  | 5.5         | 2:1      | 1080 x 2160    |
| Google Pixel                   | Android  | 5.0         | 16 : 9   | 1080 x 1920    |
| Samsung Galaxy A70，A80        | Android  | 6.7         | 20 : 9   | 1080 x 2400    |
| Samsung Galaxy A60             | Android  | 6.3         | 19.5 : 9 | 1080 x 2340    |
| Huawei P40 Pro+                | 鸿蒙 OS  | 6.58        | 11 : 5   | 1200 x 2640    |
| Huawei P40 Pro                 | 鸿蒙 OS  | 6.58        | 11 : 5   | 1200 x 2640    |

[^2] 自iPhone 12发布之后。各大主流手机制造商在屏幕设计上的选择都逐渐趋于统一，因此这里对于那之后的产品就不再进行罗列了。

因此，设计师们在设计网页时首先做的就是让网页在被载入时自动获取当前网页浏览器的视口尺寸。为了完成好这项工作，我们在这里会推荐读者使用Google Chrome浏览器的调试工具来模拟各种移动端设备，具体方法是通过单击调试工具界面顶部工具栏中的移动设备图标（如图2所示）来打开该调试工具的移动端模式：

![Google Chrome移动端调试](./img/html&css/3.png)

在启动调试工具的移动端模式之后，设计师们就可以通过上述图中移动端视图顶部的屏幕参数控制栏中具体调整自己所需要的视口尺寸。而关于对视口尺寸的自动感知问题，当今市面上流行着几种面向不同平台的解决方案，鉴于本书要讨论的是基于HTML5+CSS3的解决方案，所以下面还是来重点介绍一下这个解决方案的基本思路吧。

在基于HTML5+CSS3技术的解决方案中，让网页在各种移动设备上自动适配屏幕的工作通常被称作*响应式设计（Responsive Web Design，简称 RWD）*。RWD是由美国著名的网页设计师Ethan Marcotte在2010年5月首度提出的一种面向移动端应用的用户界面设计方式，这种设计方式致力于让基于HTML5来定义的网页自动检测移动端设备的视口尺寸，并根据该尺寸来调整网页中各界面元素的外观、大小以及布局方式。总体而言，这一设计方案大致上可以被视为是以下三种不同的技术搭配使用：

- **流体网格**：这项技术概念的核心是要求设计师们在进行网页设计时尽可能使用百分比、`rpx`或`rem`这样的相对单位，而不要使用像素点（即`px`）这样的绝对单位。
- **响应式图片**：这种图片应该可以使用百分比等相对单位来调整大小（最大到100%），这样做可以防止图片元素显示于它们的上层元素外。
- **媒体查询**：这项技术可以让应用程序的用户界面自动获取其当前所在的屏幕情况，并采用不同CSS规则定义其外观样式。

需要特别强调的是， RWD不是一项被Ethan Marcotte发明出来的、独立存在的全新技术，它本质上只是对现有技术的一种灵活运用，是一种从实践经验中总结的方法论。例如在设计页面的CSS样式时，读者可以像下面这样来定义该页面分别在窄屏和宽屏情况下的外观样式：

```CSS
/* 假设以下CSS代码已经关联到某一HTML文档上,
 * 并且该文档中存在着一个由<nav>标签定义的导航栏元素
 */
nav {
    float: right;
}

nav ul {
    padding: 0;
    margin: 0;
    list-style: none;
}

nav ul li {
    color: #a2a0a0;
    float: left;
    text-transform: uppercase;
    transition: background 0.5s ease;
}

nav ul li:hover {
    color: white;
    background: #aaa;
}

nav ul li.active {
    color: white;
    background: #343831;
}

nav ul li a {
    display: block;
    padding: 0 40rpx;
    line-height: 100rpx;
    color: inherit;
    cursor: pointer;
    transition: all 0.3s ease;
}

@media screen and (max-width: 768px) {
    nav {
        width: 100%;
        padding: 100rpx 0 30rpx;
    }

    nav ul li {
        float: none;
        border-bottom: 1rpx solid lightgray;
    }
}
```

在上述代码中，`@media`是CSS中的媒体查询指令，该指令可以让指定HTML文档中的导航栏元素在浏览器视口小于768个像素时采用面向移动端屏幕的布局方式。现如今，市面上主流的网页布局方式都基本是响应式的，而且如今的各种网页浏览器中也内置了一些新的机制，这些机制也进一步使得网页对移动端视口感知变得更加容易。例如在HTML5文档中，设计师们往往还会选择通过在`<head>`标签中加入`<meta name="viewport">`标签的方式来加强网页对视口尺寸的感知功能，例如像这样：

```HTML
<meta name="viewport" content="width=device-width,initial-scale=1">
```

在上述`<meta>`标签中，我们利用HTML5提供的`device-width`关键字将应用程序的视口宽度设定为当前设备的屏幕宽度，同时也将文档放大到其预期大小的100%，当然了，之所以要设置这个标签，主要是因为移动端的浏览器会倾向于在它们的视口宽度上说谎。众所周知，自从iPhone横空出世以来，人们开始在手机屏幕上查看网络信息。而由于在相当长的一段时间里，大多数网页并未对移动端做针对性优化的关系，移动端的浏览器通常选择默认的视口宽度设置960像素，并基于这个宽度来渲染网页，其渲染的效果就变成了其在PC端浏览器上的缩放版本，这种情况带来的用户体验是非常糟糕的。

更糟糕的是，如果是在网页的初始化阶段，上述基于媒体查询等技术所做的响应式设计在某些移动端浏览器中可能无法正常地发挥作用。在这种情况下，设计师们只需要在`<meta>`标签中加入`width=device-width`这样的设定，就可以让网页在初始化阶段自动获取到所在设备的实际视口尺寸，并用它覆写移动端浏览器默认的视口尺寸。这样一来，网页的初始化问题就可以得到很好的解决了。

### 配色方案设计

下面来继续介绍另一个网页设计师们在网页设计工作中要解决的关键问题：设计网页的配色方案，该问题对于网站的用户体验和品牌标识具有着非常重要的影响。因此，在启动一个网页设计项目时，设计师们首要任务之一就是要为网站设计一个符合其所属企业或个人的配色方案，以便增强用户对相关品牌标识的认知和记忆。例如，如今的人看到黄底黑字的配色很容易联想到美团外卖，看到红加白的配色可能就会联想到蜜雪冰城等。为了能更好达成这一目的，读者在设计网站的配色方案时通常需要选择好其网页要使用的主要颜色、辅助颜色和背景颜色，而关于颜色的选择，设计师们通常会基于以下因素来完成他们的工作。

1. **品牌标识**：设计师们在为网站选择配色方案时通常都要与该网站所属企业或个人的品牌标识保持一致，这样做将有助于建立品牌的视觉一致性和识别度。
2. **色彩心理学**：设计师们需要了解不同颜色可以激发不同的情感和反应，以确保自己所选的配色方案与网站所要传递的信息内容在目标上保持一致。例如，蓝色通常与冷静和信任相关，红色可能传达激情和警戒。
3. **对比度和可读性**：在网页中，文本和背景之间的对比度对于文字的可读性至关重要。因此，设计师们在设计配色方案时需要让文本在颜色上与其背景之间形成足够的对比，以使提高文本的可读性。
4. **无障碍性**：为了确保网站对所有用户都友好，设计师们在设计配色方案时需要充分考虑颜色对于视力受损人士的可访问性。例如，选择对比度较大的颜色，以便视力受损用户也能轻松阅读和浏览内容。

在选择好配色方案之后，设计师们的下一个任务是将该配色方案编写成CSS样式代码。在这个任务中，设计师们首先需要将配色方案中的每个颜色进行编码，以便能被计算机及其软件识别并渲染在显示设备中。下面是几种在CSS样式代码中常用的颜色编码方式：

1. **RGB**：RGB是一种将红色、绿色和蓝色组合在一起来表示颜色的方法。每个颜色通道的取值范围是0到255，其中0表示没有颜色，255表示最大强度的颜色。通过调整三个通道的数值，可以创建各种不同的颜色。例如，纯红色可以表示为RGB(255, 0, 0)。
2. **Hex**：即十六进制颜色代码，这是一种使用六个字符（0-9和A-F）来表示颜色的方法。每个字符对应于RGB通道的强度值。前两个字符表示红色通道，中间两个字符表示绿色通道，最后两个字符表示蓝色通道。例如，纯红色可以表示为#FF0000。
3. **HSL**：HSL是一种使用色相、饱和度和亮度三个参数来表示颜色的方法。色相表示颜色在色轮上的位置，取值范围是0到360度。饱和度表示颜色的纯度或灰度程度，取值范围是0%到100%。亮度表示颜色的明亮程度，取值范围是0%到100%。通过调整这三个参数的值，可以创建各种不同的颜色。
4. **RGBA**：RGBA是一种与RGB类似的表示颜色的方法，但多了一个透明度通道。透明度通道的取值范围是0到1，其中0表示完全透明，1表示完全不透明。RGBA可以用于创建具有不同透明度的颜色，使得网页元素可以显示出层次感和透明效果。

在颜色在计算机中的编码方式之后，读者接下来要做的是将颜色编码定义成可在CSS样式代码中重复使用的变量（这在维护和修改样式时非常有用）。这个任务可以利用CSS提供的自定义属性来实现。在这里，本书会建议读者按照以下步骤来完成这个任务。

1. 首先定义一个名为`:root`的伪根类选择器，并将要使用的颜色编码设置成该选择器的自定义属性（只有`:root`伪类选择器的自定义属性可被全局使用，一般选择器的自定义属性只能在与之匹配的页面元素中被使用）。按照约定俗成，设计师们通常会使用`--`前缀来表示这些自定义颜色的名称。例如，读者可以先像下面这样在`:root`伪类选择器中定义了一个名为`--primary-bg-color`的自定义属性，并用RGB的编码方式将它的值设置成`rgb(164, 205, 223)`。

    ```css
    :root {
        --primary-bg-color: rgb(164, 205, 223);
    }
    ```

2. 接下来，读者就可以在整个CSS样式表中通过`var( --primary-bg-color)`的方式来使用这个自定义颜色了。通过这种方式，设计师们就可以轻松地在整个CSS样式文件中引用相同的颜色值，而不必多次输入Hex或RGB编码。如果需要更改颜色，只需在`:root`伪类中更新自定义属性的值即可，而不必在整个样式文件中查找并替换颜色值。例如，读者可以选择像下面这样将一系列页面元素的背景色（即这些元素的`background-color`）设置成这个自定义颜色。之后如果想修改这些页面元素的背景色，就只需要修改`:root`伪类的`--primary-bg-color`属性值即可。

    ```css
    body {
        /* 设置网页主体部分的背景色 */        
        background-color: var(--primary-bg-color);
    }

    #box {
         /* 设置网页中id=“box”的元素所使用的背景色 */
        background-color: var(--primary-bg-color);
    }

    .button {
         /* 设置网页中class="button"的元素所使用的背景色 */
        background-color: var(--primary-bg-color);
    }
    ```

当然了，考虑到CSS本身也为用户提供了一系列预定义的颜色名称，本书在这里会建议读者在对自己使用的颜色编码进行命名之前，最好先查看一下该颜色编码是否已经存在于下面的预定义颜色表中，以避免重复发明轮子，浪费了自己宝贵的时间。

| 颜色名称   | 颜色值       | 颜色名称   | 颜色值       | 颜色名称   | 颜色值       |
| ----------- | ------------ | ----------- | ------------ | ----------- |---------- |
| AliceBlue   | #F0F8FF      | AntiqueWhite| #FAEBD7      | Aqua        | #00FFFF      |
| Aquamarine  | #7FFFD4      | Azure       | #F0FFFF      | Beige       | #F5F5DC      |
| Bisque      | #FFE4C4      | Black       | #000000      | BlanchedAlmond | #FFEBCD   |
| Blue        | #0000FF      | BlueViolet  | #8A2BE2      | Brown       | #A52A2A      |
| BurlyWood   | #DEB887      | CadetBlue   | #5F9EA0      | Chartreuse  | #7FFF00      |
| Chocolate   | #D2691E      | Coral       | #FF7F50      | CornflowerBlue | #6495ED   |
| Cornsilk    | #FFF8DC      | Crimson     | #DC143C      | Cyan        | #00FFFF      |
| DarkBlue    | #00008B      | DarkCyan    | #008B8B      | DarkGoldenRod | #B8860B   |
| DarkGray    | #A9A9A9      | DarkGreen   | #006400      | DarkKhaki   | #BDB76B      |
| DarkMagenta | #8B008B      | DarkOliveGreen | #556B2F   | DarkOrange  | #FF8C00      |
| DarkOrchid  | #9932CC      | DarkRed     | #8B0000      | DarkSalmon  | #E9967A      |
| DarkSeaGreen | #8FBC8F    | DarkSlateBlue | #483D8B    | DarkSlateGray | #2F4F4F    |
| DarkTurquoise | #00CED1    | DarkViolet  | #9400D3      | DeepPink    | #FF1493      |
| DeepSkyBlue | #00BFFF      | DimGray     | #696969      | DodgerBlue  | #1E90FF      |
| FireBrick   | #B22222      | FloralWhite | #FFFAF0      | ForestGreen | #228B22      |
| Fuchsia     | #FF00FF      | Gainsboro   | #DCDCDC      | GhostWhite  | #F8F8FF      |
| Gold        | #FFD700      | GoldenRod   | #DAA520      | Gray        | #808080      |
| Green       | #008000      | GreenYellow | #ADFF2F      | HoneyDew    | #F0FFF0      |
| HotPink     | #FF69B4      | IndianRed   | #CD5C5C      | Indigo      | #4B0082      |
| Ivory       | #FFFFF0      | Khaki       | #F0E68C      | Lavender    | #E6E6FA      |
| LavenderBlush | #FFF0F5    | LawnGreen   | #7CFC00      | LemonChiffon | #FFFACD    |
| LightBlue   | #ADD8E6      | LightCoral  | #F08080      | LightCyan   | #E0FFFF      |
| LightGoldenRodYellow | #FAFAD2 | LightGray   | #D3D3D3      | LightGreen  | #90EE90      |
| LightPink   | #FFB6C1      | LightSalmon | #FFA07A      | LightSeaGreen | #20B2AA    |
| LightSkyBlue | #87CEFA     | LightSlateGray | #778899   | LightSteelBlue | #B0C4DE   |
| LightYellow | #FFFFE0      | Lime        | #00FF00      | LimeGreen   | #32CD32      |
| Linen       | #FAF0E6      | Magenta     | #FF00FF      | Maroon      | #800000      |
| MediumAquaMarine | #66CDAA | MediumBlue  | #0000CD      | MediumOrchid | #BA55D3    |
| MediumPurple | #9370DB     | MediumSeaGreen | #3CB371   | MediumSlateBlue | #7B68EE   |
| MediumSpringGreen | #00FA9A | MediumTurquoise | #48D1CC  | MediumVioletRed | #C71585  |
| MidnightBlue | #191970    | MintCream   | #F5FFFA      | MistyRose   | #FFE4E1      |
| Moccasin    | #FFE4B5      | NavajoWhite | #FFDEAD      | Navy        | #000080      |
| OldLace     | #FDF5E6      | Olive       | #808000      | OliveDrab   | #6B8E23      |
| Orange      | #FFA500      | OrangeRed   | #FF4500      | Orchid      | #DA70D6      |
| PaleGoldenRod | #EEE8AA   | PaleGreen   | #98FB98      | PaleTurquoise | #AFEEEE    |
| PaleVioletRed | #DB7093   | PapayaWhip  | #FFEFD5      | PeachPuff   | #FFDAB9      |
| Peru        | #CD853F      | Pink        | #FFC0CB      | Plum        | #DDA0DD      |
| PowderBlue  | #B0E0E6      | Purple      | #800080      | RebeccaPurple | #663399    |
| Red         | #FF0000      | RosyBrown   | #BC8F8F      | RoyalBlue   | #4169E1      |
| SaddleBrown | #8B4513      | Salmon      | #FA8072      | SandyBrown  | #F4A460      |
| SeaGreen    | #2E8B57      | SeaShell    | #FFF5EE      | Sienna      | #A0522D      |
| Silver      | #C0C0C0      | SkyBlue     | #87CEEB      | SlateBlue   | #6A5ACD      |
| SlateGray   | #708090      | Snow        | #FFFAFA      | SpringGreen | #00FF7F      |
| SteelBlue   | #4682B4      | Tan         |

在实际项目实践中，设计师常常会根据自己的偏好和项目的具体需求来搭配使用上面这些颜色表述方法，以便设计出可文档化的网页配色方案，比如使用RGB或Hex代码来表示颜色，同时使用HSL来调整颜色的亮度和饱和度。

<!-- 以下资料来自维基百科 -->

引入CSS规则的多种方式及其层叠性

CSS可以有多种引入方式，一个网页可以引入多个CSS文件，同一种CSS规则可以被反复多次添加。这使得CSS的使用方式非常灵活，但也会频繁地出现规则冲突。同时对一个网页元素设定无法并存的2种样式时，就会引起冲突。CSS的特色之一就是其解决规则冲突的方案。CSS的规则冲突可以分为不同来源之间的规则冲突和同一来源内部的规则冲突。CSS分层次、立体化的比较不同规则的优先级的方式，就是所谓层叠性(cascading)的体现。

首先说来源的多样性，CSS信息可以来自：

作者样式
作者可以在他的HTML文件中确定一个外来的、独立的CSS文件（外部样式表），其优先级最低
作者可以将CSS信息包含在HTML文件内（内部样式表）
作者可以在一个HTML指令内结合CSS指令（内联样式），其优先级最高。一般这样做是为了在特殊情况下，把上面来源的CSS抵消掉
客户端自定义样式（client-side style sheet）
浏览网页的用户可以自己在本地计算机上自己写1个CSS文件，然后就可以在浏览器内通过设置好特定选项，来加载自己的CSS文件。这个CSS文件可以用在所有的HTML文件上。当网页作者没有设定某项规则，但存在对应的用户自定义规则时，用户的规则就会起作用。假如作者的CSS文件与读者的相冲突，浏览器会采用作者的规则。如果读者有特殊要求，可以通过在自定义规则末尾添加!important提升自定义规则的显示优先权。(网页作者也可以使用!important给规则提升权限，但是优先级别比不过由用户写的!important声明，!important对于网页作者的意义仅在于网页开发阶段的规则冲突测试)
浏览器样式
假如外部没有特别指定一个样式的话，一般浏览器自己有一个内在的样式。由于不同浏览器的默认样式并不一致，所以讲究美观的网页的设计者一般喜欢去掉这个默认的样式。
其次还需知道规则特殊性(specificity)的概念。某个规则的特殊性也常被称为该规则的具体程度。规则特殊性的高低次序如下（依次递减）：

行内样式
ID选择器
class选择器
标签选择器
通用选择器（也就是通配符选择器，用得少）
特殊性优先原则
特殊性优先原则是最重要的优先级比较规则。当引起冲突的2种规则的特殊性存在差异时（例如一个是通过ID选择器指定样式，另一个是通过class选择器指定样式），引擎将优先采用特殊性更高的样式。规则的特殊性的比较是最优先的。如果能直接判断出特殊性的差异，就无需考虑其它规则了。

不同来源的规则优先性
不同来源的规则之间的优先原则是第二重要的。当规则来源相同时（同为外部样式或同为内部样式），下一步就需要比较不同类型来源的优先级别。总地来说，记住“行内样式优先于内部样式，内部样式又优先于外部样式”即可应对多数常见的情形。像网页浏览者自定义样式表的优先级别如何，只有浏览器的设计者才需要考虑，与网页设计者的关系不大。

如果考虑有可能出现的更复杂的来源冲突，内容就比较多了。但一般在写样式时，应尽可能避免这些复杂情形的出现。具体来说，一般情形下的采纳样式效果的优先级顺序为：[6]

行内样式
内部样式
在HTML中通过<link>标签直接引入的外部样式表
在CSS中通过@import语句间接引入的外部样式表
浏览网页的用户自己定义的样式表（需要手动加载）
浏览器默认的样式（如标题有默认大小、段落之间有默认间距等，不同浏览器的默认样式不完全一样）
CSS中还有用!important修饰的重要性声明。如果计入重要性声明，那么在以上规则的最前面还需要加上2条规则：

用户从本地加载的重要自定义样式
网页设计者设定的重要样式
设计重要性声明是为部分特殊用户和所有开发者提供方便。一方面，用户可以通过设置自己的色彩方案，并对其使用重要性声明来提升浏览体验。另一方面，网页的设计者难免会遇到因规则冲突而导致特定样式规则失效的情形，设计者可以通过给不知何故不起作用的规则增加重要性声明，看看是否有样式变化来确定是否是不小心导致了规则冲突而引起特定规则被覆盖失效。

权重分数比较机制
有时还会遇到选择器优先级无法直接判断，而且规则的来源也相同的情形。如果网页设计者很少使用层次比较复杂的选择器（比如多级的后代选择器），那么必须比较权重的情况一般不会遇到（一般要么是可以直接根据前面的规则判断出优先性结果，或者是起冲突的2条规则的权重完全一样，只能继续去看后一条比较出现次序的机制）。此时，CSS还有一套分数加权(或者说是分数累积)的机制用于解决此类规则冲突。先列出基本的分值：

1个行内样式占1000分
1个id选择器占100分
1个class选择器占10分
1个标签选择器占1分
组合使用多个基本选择器时，不同选择器的得分会累加到一起。最终得分高的选择器，其指定的样式会胜出。

举例：
.type1 #id3{color: green; font-size: 20px;}
div p #id3{color: blue; background-color: grey;}
假设这2行代码都能够选中同一个ID为“id3”的元素，且都是出自同一来源的样式表。可以看到，二者使用的优先级最高的选择器都是ID选择器，起冲突的样式设置是字体颜色。一个给此元素设置字体颜色为绿色，另一个给此元素设置字体颜色为蓝色。按照评分规则，因为前一种代码使用了1个类选择器和1个id选择器，所以得分为10+100=110分；后一种代码使用了2个标签选择器和1个id选择器，所以得分为1+1+100=102分。因为110分>102分，所以前一种规则胜出，目标元素的最终文字颜色应该是绿色。

靠后者优先原则
当权重比较仍然不能分出优先级胜负时，最后就是把守关底的“靠后优先”的原则了，也就是后定义的样式优先级较高。如果起冲突的规则来源相同，而且得分也相同，那么最后的冲突解决法则就是看CSS代码出现的先后顺序。后出现的规则会覆盖掉与之优先级相当的先出现的规则。也可称作“后发制人”、“后来者居上”或“后浪推前浪”原则，随便你怎么称呼。这种原则的适用情形很常见，所以此规则也很重要。

行级元素与块级元素
[icon]	此章节需要扩充。 (2018年4月21日)
方盒模型
[icon]	此章节需要扩充。 (2018年4月21日)
浮动与定位
[icon]	此章节需要扩充。 (2018年4月21日)
包含块、定位
包含块是CSS定位属性所依托的理论模型。

层次与层叠上下文
层叠上下文规则决定了当有网页元素位置发生部分重合时，重合部分的上下叠放次序。层叠上下文规则详细规定了当浮动、定位以及z轴数值同时出现时，元素叠放次序的总规则。

格式化上下文
格式化上下文有特殊的布局性质，巧妙创建格式化上下文可以解决方便地达到几种特殊目的：[7]

避免垂直方向不同元素的相邻外边距自动合并
清除因为为子元素设置了浮动而可能造成的父元素高度塌陷
实现一列宽度固定、一列宽度不固定的双列宽度自适应布局
其它
CSS檔內也可以包含注釋，注釋放在/*和*/之间。一般的浏览器也识别以双斜杠(//)开头的这种注释，但是这是不规范的做法。

特点
優勢
网页的讀者和作者都可以使用CSS来决定文件的颜色、字体、排版等显示特性。CSS最主要的目的是将文件的内容与显示分隔开来。这有许多好处：

文件的可读性加强
文件的结构更加灵活
作者和读者可以自己决定文件的显示
文件的结构简化了
另外，在HTML中：

一个整个网站或其中一部分网页的显示信息被集中在一个地方，要改变它们很方便
不同的读者可以有不同的样式，比如有的读者需要字体比较大
HTML文件本身的范围变小了，它的结构简单了，它不需要包含显示的信息
CSS还可以控制其他参数，例如声音（假如浏览器有阅读功能的话）或给視障者用的感受装置。

缺点
CSS明顯的缺點包括：

瀏覽器不同的支援
瀏覽器对CSS的支持没有统一，造成不同的瀏覽器顯示效果不同。例如在微軟Internet Explorer的舊版本6.0，有許多独有的CSS 2.0屬性，但錯誤顯示很多重要的屬性，例如：width，height，和float[24]。許多CSS编写人員为了尽可能在常用的各个瀏覽器中達到一致的版面編排，要写很多针对各个浏览器的不同的CSS代码。当版面编排很复杂时，要在各个浏览器裏取得相同效果是不可能的。
CSS沒有父選擇器
CSS選擇器無法提供元素的繼承性。先進的選擇器（例如XPath）有助於複雜的樣式設計。然而，瀏覽器的性能和增加彩現的問題，關係著父層選擇器，卻是CSS的工作群組拒絕建議的主要原因。
而CSS4則計劃包括類似功能。
不能明確地指定繼承性
樣式的繼承性，建立在瀏覽器中DOM元素的層級和具體的規則上，參照CSS2說明中的章節6.4.1。[25]
垂直控制的局限
元素的水平放置普遍地易於控制，垂直控制則不然。簡單來說，垂直地圍繞一個元素、頁尾的放置不能高於可見視窗（viewport，視窗或螢幕的可見範圍[26]）的底部範圍。这需要複雜的樣式規則，或是規則簡單，但不被廣泛支援。
没有算术功能
直至CSS 2.1的CSS沒有辦法明確簡單地进行计算（例如：margin-left: 10% - 3em + 4px;）。计算功能在很多情況下都是非常有用的，例如：總欄位中計算欄位的尺寸限制。無論如何，CSS WG[27]發表了CSS局限性的草案。IE 5至IE 7提供expression()函数（即所谓的CSS表达式）来执行计算功能，例如left: expression（document.body.offsetWidth - 110 + "px"）; 。为了與CSS标准看齐，并且该函数性能差，微軟从IE 8开始停止支持此函数。
CSS 3中具有calc()表达式以执行计算功能[28][29]。
p {
    margin: calc (1rem - 2px) calc (1rem - 1px) 
}
缺乏唯一性
同樣的效果可以用不同的屬性來完成，這对不少的CSS編寫人員造成困擾。例如position、display與float定義了不同的配置方式，而且不能有效的交替使用。一個display: table-cell元素不能指定float或是position: relative，因為指定float: left的元素不應該受到display效果的影響。再者，沒有考慮到新建立屬性所造成的影響，例如在表格中你應該使用border-spacing而不是margin-*來指定表格元素。這是因為依照CSS準則，表格內部元素是沒有邊界（margin）的。
CSS的性能优化
使用语法缩写
使用CSS缩写可以减少CSS文件的大小，并使其更为易读[30]。例如：颜色缩写（缩写16进制的色彩值）、盒尺寸缩写、边框缩写、背景缩写和文字缩写。
